<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DHART: HF::SpatialStructures::Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome-css.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DHART
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a01551.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="a01548.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">HF::SpatialStructures::Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="a01551.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">Graph</a> of nodes connected by edges that supports both integers and <a class="el" href="a02071.html" title="A point in space with an ID.">HF::SpatialStructures::Node</a>.  
 <a href="a01551.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00269_source.html">graph.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for HF::SpatialStructures::Graph:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01549.svg" width="1118" height="672"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a738bbf6e1d4d8eefd9884e7d117d4ef5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a738bbf6e1d4d8eefd9884e7d117d4ef5">Graph</a> (const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges, const std::vector&lt; std::vector&lt; float &gt; &gt; &amp;distances, const std::vector&lt; <a class="el" href="a02071.html">Node</a> &gt; &amp;<a class="el" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>, const std::string &amp;<a class="el" href="a01551.html#aba19080a765d7a09b0acbf8ffdcd1277">default_cost</a>=&quot;Distance&quot;)</td></tr>
<tr class="memdesc:a738bbf6e1d4d8eefd9884e7d117d4ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a graph from a list of nodes, edges, and distances.  <a href="a01551.html#a738bbf6e1d4d8eefd9884e7d117d4ef5">More...</a><br /></td></tr>
<tr class="separator:a738bbf6e1d4d8eefd9884e7d117d4ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2386d87722e4459b70dc2995a7bf2be4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a2386d87722e4459b70dc2995a7bf2be4">Graph</a> (const std::string &amp;default_cost_name=&quot;Distance&quot;)</td></tr>
<tr class="memdesc:a2386d87722e4459b70dc2995a7bf2be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty graph.  <a href="a01551.html#a2386d87722e4459b70dc2995a7bf2be4">More...</a><br /></td></tr>
<tr class="separator:a2386d87722e4459b70dc2995a7bf2be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00121404a647b0d619f201cf9ebc797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#af00121404a647b0d619f201cf9ebc797">HasEdge</a> (const std::array&lt; float, 3 &gt; &amp;parent, const std::array&lt; float, 3 &gt; &amp;child, bool undirected=false) const</td></tr>
<tr class="memdesc:af00121404a647b0d619f201cf9ebc797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge from parent to child.  <a href="a01551.html#af00121404a647b0d619f201cf9ebc797">More...</a><br /></td></tr>
<tr class="separator:af00121404a647b0d619f201cf9ebc797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bfa0a8e88ef1fdf54597597b1a1291"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#ab6bfa0a8e88ef1fdf54597597b1a1291">HasEdge</a> (const <a class="el" href="a02071.html">Node</a> &amp;parent, const <a class="el" href="a02071.html">Node</a> &amp;child, const bool undirected=false, const std::string cost_type=&quot;&quot;) const</td></tr>
<tr class="memdesc:ab6bfa0a8e88ef1fdf54597597b1a1291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge from parent to child.  <a href="a01551.html#ab6bfa0a8e88ef1fdf54597597b1a1291">More...</a><br /></td></tr>
<tr class="separator:ab6bfa0a8e88ef1fdf54597597b1a1291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8932d45fe1608935afcdc20b462ec93b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a8932d45fe1608935afcdc20b462ec93b">HasEdge</a> (int parent, int child, bool undirected=false, const std::string &amp;cost_type=&quot;&quot;) const</td></tr>
<tr class="separator:a8932d45fe1608935afcdc20b462ec93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a02071.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a> () const</td></tr>
<tr class="memdesc:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of nodes from the graph sorted by ID.   <a href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">More...</a><br /></td></tr>
<tr class="separator:aa70347b8a33b57c6f0a72d6eca4248d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86208fa647a5a7fdbc18c0cd9d5d5a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01527.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#ac86208fa647a5a7fdbc18c0cd9d5d5a3">GetUndirectedEdges</a> (const <a class="el" href="a02071.html">Node</a> &amp;N, const std::string &amp;cost_type=&quot;&quot;) const</td></tr>
<tr class="memdesc:ac86208fa647a5a7fdbc18c0cd9d5d5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of all edges to and from node N.   <a href="a01551.html#ac86208fa647a5a7fdbc18c0cd9d5d5a3">More...</a><br /></td></tr>
<tr class="separator:ac86208fa647a5a7fdbc18c0cd9d5d5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a26ebb794b444e2214cf0b0fed5a529"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01535.html">EdgeSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a1a26ebb794b444e2214cf0b0fed5a529">GetEdges</a> () const</td></tr>
<tr class="memdesc:a1a26ebb794b444e2214cf0b0fed5a529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get every in the given graph as IDs.   <a href="a01551.html#a1a26ebb794b444e2214cf0b0fed5a529">More...</a><br /></td></tr>
<tr class="separator:a1a26ebb794b444e2214cf0b0fed5a529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5227cd95744b58551b9964975017a37"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01531.html">IntEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#ad5227cd95744b58551b9964975017a37">GetIntEdges</a> (int parent) const</td></tr>
<tr class="memdesc:ad5227cd95744b58551b9964975017a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get children of a specific node as integers.  <a href="a01551.html#ad5227cd95744b58551b9964975017a37">More...</a><br /></td></tr>
<tr class="separator:ad5227cd95744b58551b9964975017a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487b0b29dc7c554089e0255779218567"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a487b0b29dc7c554089e0255779218567">AggregateGraph</a> (<a class="el" href="a00465.html#a6b23c0b2531c78f6d5049873c184f4f9">COST_AGGREGATE</a> agg_type, bool directed=true, const std::string &amp;cost_type=&quot;&quot;) const</td></tr>
<tr class="memdesc:a487b0b29dc7c554089e0255779218567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summarize the costs of every outgoing edge for every node in the graph.   <a href="a01551.html#a487b0b29dc7c554089e0255779218567">More...</a><br /></td></tr>
<tr class="separator:a487b0b29dc7c554089e0255779218567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2ea4fda7d310b500456ff14527bab9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="a01527.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a7c2ea4fda7d310b500456ff14527bab9">operator[]</a> (const <a class="el" href="a02071.html">Node</a> &amp;n) const</td></tr>
<tr class="separator:a7c2ea4fda7d310b500456ff14527bab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37be5c12e488072dea7fa1c8c64346f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a37be5c12e488072dea7fa1c8c64346f7">addEdge</a> (const <a class="el" href="a02071.html">Node</a> &amp;parent, const <a class="el" href="a02071.html">Node</a> &amp;child, float score=1.0f, const std::string &amp;cost_type=&quot;&quot;)</td></tr>
<tr class="memdesc:a37be5c12e488072dea7fa1c8c64346f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new edge to the graph from parent to child.   <a href="a01551.html#a37be5c12e488072dea7fa1c8c64346f7">More...</a><br /></td></tr>
<tr class="separator:a37be5c12e488072dea7fa1c8c64346f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0584ab845d5c21979b1542651a4cf3aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a0584ab845d5c21979b1542651a4cf3aa">addEdge</a> (int parent_id, int child_id, float score, const std::string &amp;cost_type=&quot;&quot;)</td></tr>
<tr class="memdesc:a0584ab845d5c21979b1542651a4cf3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new edge to the graph from parent to child.   <a href="a01551.html#a0584ab845d5c21979b1542651a4cf3aa">More...</a><br /></td></tr>
<tr class="separator:a0584ab845d5c21979b1542651a4cf3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de020064d58c4ab376a26c30be863a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a4de020064d58c4ab376a26c30be863a3">hasKey</a> (const <a class="el" href="a02071.html">Node</a> &amp;n) const</td></tr>
<tr class="memdesc:a4de020064d58c4ab376a26c30be863a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if n exists in the graph.   <a href="a01551.html#a4de020064d58c4ab376a26c30be863a3">More...</a><br /></td></tr>
<tr class="separator:a4de020064d58c4ab376a26c30be863a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddbbec01c6354b7076f47f71fc1a220"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; float, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#aeddbbec01c6354b7076f47f71fc1a220">NodesAsFloat3</a> () const</td></tr>
<tr class="memdesc:aeddbbec01c6354b7076f47f71fc1a220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of nodes as float arrays.   <a href="a01551.html#aeddbbec01c6354b7076f47f71fc1a220">More...</a><br /></td></tr>
<tr class="separator:aeddbbec01c6354b7076f47f71fc1a220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2710af2a75976862d7a235793567d2f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a2710af2a75976862d7a235793567d2f3">size</a> () const</td></tr>
<tr class="memdesc:a2710af2a75976862d7a235793567d2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how many nodes are in the graph.   <a href="a01551.html#a2710af2a75976862d7a235793567d2f3">More...</a><br /></td></tr>
<tr class="separator:a2710af2a75976862d7a235793567d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1505ad796c9f222c923a1a22980bb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a5d1505ad796c9f222c923a1a22980bb2">MaxID</a> () const</td></tr>
<tr class="memdesc:a5d1505ad796c9f222c923a1a22980bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the maximum ID of any node in the graph.  <a href="a01551.html#a5d1505ad796c9f222c923a1a22980bb2">More...</a><br /></td></tr>
<tr class="separator:a5d1505ad796c9f222c923a1a22980bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59beedafb4af0ee99d54761e1c681fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#af59beedafb4af0ee99d54761e1c681fc">getID</a> (const <a class="el" href="a02071.html">Node</a> &amp;node) const</td></tr>
<tr class="memdesc:af59beedafb4af0ee99d54761e1c681fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the ID for node in this graph.   <a href="a01551.html#af59beedafb4af0ee99d54761e1c681fc">More...</a><br /></td></tr>
<tr class="separator:af59beedafb4af0ee99d54761e1c681fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cece77d0eee98df39ecc6d3a366ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a41cece77d0eee98df39ecc6d3a366ec8">Compress</a> ()</td></tr>
<tr class="memdesc:a41cece77d0eee98df39ecc6d3a366ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress the graph to a CSR and enable the usage of several functions.  <a href="a01551.html#a41cece77d0eee98df39ecc6d3a366ec8">More...</a><br /></td></tr>
<tr class="separator:a41cece77d0eee98df39ecc6d3a366ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd5d401dfbd61b3b075ca0ad63d959e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01539.html">CSRPtrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a7cd5d401dfbd61b3b075ca0ad63d959e">GetCSRPointers</a> (const std::string &amp;cost_type=&quot;&quot;)</td></tr>
<tr class="memdesc:a7cd5d401dfbd61b3b075ca0ad63d959e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the size of and pointers to the 3 arrays that comprise this graph's CSR. graph if it isn't compressed already   <a href="a01551.html#a7cd5d401dfbd61b3b075ca0ad63d959e">More...</a><br /></td></tr>
<tr class="separator:a7cd5d401dfbd61b3b075ca0ad63d959e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794c342603cefb342fdc698ba539b25f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02071.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a794c342603cefb342fdc698ba539b25f">NodeFromID</a> (int id) const</td></tr>
<tr class="memdesc:a794c342603cefb342fdc698ba539b25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the node that corresponds to id.   <a href="a01551.html#a794c342603cefb342fdc698ba539b25f">More...</a><br /></td></tr>
<tr class="separator:a794c342603cefb342fdc698ba539b25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994dbd15119eb6548d2e15f4de4b88a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a994dbd15119eb6548d2e15f4de4b88a6">Clear</a> ()</td></tr>
<tr class="memdesc:a994dbd15119eb6548d2e15f4de4b88a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all nodes and edges from the graph.   <a href="a01551.html#a994dbd15119eb6548d2e15f4de4b88a6">More...</a><br /></td></tr>
<tr class="separator:a994dbd15119eb6548d2e15f4de4b88a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8abc9a6de7add5c18492fdd5d8b2066"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a02071.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#ae8abc9a6de7add5c18492fdd5d8b2066">GetChildren</a> (const <a class="el" href="a02071.html">Node</a> &amp;n) const</td></tr>
<tr class="memdesc:ae8abc9a6de7add5c18492fdd5d8b2066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve n's child nodes - n is a parent node   <a href="a01551.html#ae8abc9a6de7add5c18492fdd5d8b2066">More...</a><br /></td></tr>
<tr class="separator:ae8abc9a6de7add5c18492fdd5d8b2066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73c72a75c16e9565387d3bf391430f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a02071.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a5b73c72a75c16e9565387d3bf391430f">GetChildren</a> (const int parent_id) const</td></tr>
<tr class="memdesc:a5b73c72a75c16e9565387d3bf391430f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve node parent_id's child nodes   <a href="a01551.html#a5b73c72a75c16e9565387d3bf391430f">More...</a><br /></td></tr>
<tr class="separator:a5b73c72a75c16e9565387d3bf391430f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89250c619a726fd0adbd71778d166887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00465.html#a01543">Subgraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a89250c619a726fd0adbd71778d166887">GetSubgraph</a> (const <a class="el" href="a02071.html">Node</a> &amp;parent_node, const std::string &amp;cost_type=&quot;&quot;) const</td></tr>
<tr class="memdesc:a89250c619a726fd0adbd71778d166887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a <a class="el" href="a00465.html#a01543" title="A Subgraph consists of a parent Node m_parent and a container of Edge m_edges such that all Edge in m...">Subgraph</a> using a <a class="el" href="a02071.html" title="A point in space with an ID.">Node</a>.  <a href="a01551.html#a89250c619a726fd0adbd71778d166887">More...</a><br /></td></tr>
<tr class="separator:a89250c619a726fd0adbd71778d166887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9477544edee32c4bebc69ebedd96642a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00465.html#a01543">Subgraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a9477544edee32c4bebc69ebedd96642a">GetSubgraph</a> (int parent_id, const std::string &amp;cost_type=&quot;&quot;) const</td></tr>
<tr class="memdesc:a9477544edee32c4bebc69ebedd96642a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a <a class="el" href="a00465.html#a01543" title="A Subgraph consists of a parent Node m_parent and a container of Edge m_edges such that all Edge in m...">Subgraph</a> using a parent node ID.  <a href="a01551.html#a9477544edee32c4bebc69ebedd96642a">More...</a><br /></td></tr>
<tr class="separator:a9477544edee32c4bebc69ebedd96642a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819ecd54d0148ddf867e6ca77fec8379"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a819ecd54d0148ddf867e6ca77fec8379">AddNodeAttribute</a> (int id, const std::string &amp;attribute, const std::string &amp;score)</td></tr>
<tr class="memdesc:a819ecd54d0148ddf867e6ca77fec8379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute to the node at id   <a href="a01551.html#a819ecd54d0148ddf867e6ca77fec8379">More...</a><br /></td></tr>
<tr class="separator:a819ecd54d0148ddf867e6ca77fec8379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306a0277ba1caa0aa4a1227e2f847f09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a306a0277ba1caa0aa4a1227e2f847f09">AddNodeAttributes</a> (const std::vector&lt; int &gt; &amp;id, const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;scores)</td></tr>
<tr class="memdesc:a306a0277ba1caa0aa4a1227e2f847f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute to the node at id. If the node at id already has a score for the attribute at name, then existing score should be overwritten   <a href="a01551.html#a306a0277ba1caa0aa4a1227e2f847f09">More...</a><br /></td></tr>
<tr class="separator:a306a0277ba1caa0aa4a1227e2f847f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd218785fbf6dabaa2fba2dca738618"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#aedd218785fbf6dabaa2fba2dca738618">GetNodeAttributes</a> (std::string attribute) const</td></tr>
<tr class="memdesc:aedd218785fbf6dabaa2fba2dca738618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the score for the given attribute of every node in the graph. Nodes that do not have a score for this attribute should return an empty string for this array.   <a href="a01551.html#aedd218785fbf6dabaa2fba2dca738618">More...</a><br /></td></tr>
<tr class="separator:aedd218785fbf6dabaa2fba2dca738618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0279f117df3d0d29d0a06301dac146a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a0279f117df3d0d29d0a06301dac146a9">ClearNodeAttributes</a> (std::string name)</td></tr>
<tr class="memdesc:a0279f117df3d0d29d0a06301dac146a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the attribute at name and all of its contents from the internal hashmap   <a href="a01551.html#a0279f117df3d0d29d0a06301dac146a9">More...</a><br /></td></tr>
<tr class="separator:a0279f117df3d0d29d0a06301dac146a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a73ceca4e8c54b18c6bba02e0a129ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a0a73ceca4e8c54b18c6bba02e0a129ed">DumpToJson</a> (const std::string &amp;path)</td></tr>
<tr class="separator:a0a73ceca4e8c54b18c6bba02e0a129ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f04c5320d4bf88120f8c5e31b0fb02a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a6f04c5320d4bf88120f8c5e31b0fb02a">AddEdges</a> (const <a class="el" href="a01535.html">EdgeSet</a> &amp;edges, const std::string &amp;cost_name=&quot;&quot;)</td></tr>
<tr class="memdesc:a6f04c5320d4bf88120f8c5e31b0fb02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add multiple edges to the graph.  <a href="a01551.html#a6f04c5320d4bf88120f8c5e31b0fb02a">More...</a><br /></td></tr>
<tr class="separator:a6f04c5320d4bf88120f8c5e31b0fb02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb7f82bbc403885c378d0896c742443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a4fb7f82bbc403885c378d0896c742443">AddEdges</a> (const std::vector&lt; <a class="el" href="a01535.html">EdgeSet</a> &gt; &amp;edges, const std::string &amp;cost_name=&quot;&quot;)</td></tr>
<tr class="memdesc:a4fb7f82bbc403885c378d0896c742443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an array of edges to the graph.  <a href="a01551.html#a4fb7f82bbc403885c378d0896c742443">More...</a><br /></td></tr>
<tr class="separator:a4fb7f82bbc403885c378d0896c742443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad398849b00a0eac24c0682935d8c7966"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01535.html">EdgeSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#ad398849b00a0eac24c0682935d8c7966">GetEdges</a> (const std::string &amp;cost_name) const</td></tr>
<tr class="memdesc:ad398849b00a0eac24c0682935d8c7966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges of a specfic cost type.  <a href="a01551.html#ad398849b00a0eac24c0682935d8c7966">More...</a><br /></td></tr>
<tr class="separator:ad398849b00a0eac24c0682935d8c7966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8803f69bbfaebcdae72680e01a90b94b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a8803f69bbfaebcdae72680e01a90b94b">GetCostTypes</a> () const</td></tr>
<tr class="memdesc:a8803f69bbfaebcdae72680e01a90b94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array of all cost names within this graph.  <a href="a01551.html#a8803f69bbfaebcdae72680e01a90b94b">More...</a><br /></td></tr>
<tr class="separator:a8803f69bbfaebcdae72680e01a90b94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb134f68f988eeee4e0ba3e2a698852"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a2bb134f68f988eeee4e0ba3e2a698852">GetCost</a> (int parent_id, int child_id, const std::string &amp;cost_type=&quot;&quot;) const</td></tr>
<tr class="memdesc:a2bb134f68f988eeee4e0ba3e2a698852"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the cost from parent_id to child_id in the given cost_type.  <a href="a01551.html#a2bb134f68f988eeee4e0ba3e2a698852">More...</a><br /></td></tr>
<tr class="separator:a2bb134f68f988eeee4e0ba3e2a698852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb8dbfe1b401c67d85e7a0f361ebd69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a7fb8dbfe1b401c67d85e7a0f361ebd69">Graph::AddEdges</a> (const std::vector&lt; std::vector&lt; <a class="el" href="a01531.html">IntEdge</a> &gt; &gt; &amp;edges, const std::string &amp;cost_type)</td></tr>
<tr class="memdesc:a7fb8dbfe1b401c67d85e7a0f361ebd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of intedges to the graph.  <a href="a01551.html#a7fb8dbfe1b401c67d85e7a0f361ebd69">More...</a><br /></td></tr>
<tr class="separator:a7fb8dbfe1b401c67d85e7a0f361ebd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f51b29e611c7bb59a0f4242d6e01c73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a8f51b29e611c7bb59a0f4242d6e01c73">ClearCostArrays</a> (const std::string &amp;cost_name=&quot;&quot;)</td></tr>
<tr class="memdesc:a8f51b29e611c7bb59a0f4242d6e01c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear one or more cost arrays from the graph.  <a href="a01551.html#a8f51b29e611c7bb59a0f4242d6e01c73">More...</a><br /></td></tr>
<tr class="separator:a8f51b29e611c7bb59a0f4242d6e01c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6e9bc04bec84b28043c41c96139b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#acb6e9bc04bec84b28043c41c96139b1a">AttrToCost</a> (const std::string &amp;node_attribute, const std::string &amp;cost_to_store_as, <a class="el" href="a00465.html#afac7c4ef1cb1104941f4d5a27973b47e">Direction</a> consider=<a class="el" href="a00465.html#afac7c4ef1cb1104941f4d5a27973b47eafb4081bff9f77d65456ceb00b153e4d4">Direction::INCOMING</a>)</td></tr>
<tr class="memdesc:acb6e9bc04bec84b28043c41c96139b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate edge costs from a set of node attributes.  <a href="a01551.html#acb6e9bc04bec84b28043c41c96139b1a">More...</a><br /></td></tr>
<tr class="separator:acb6e9bc04bec84b28043c41c96139b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:acfe4780ebfdd7f66b9fa77a6f0301d52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#acfe4780ebfdd7f66b9fa77a6f0301d52">NodeAttributeValueMap</a> = robin_hood::unordered_map&lt; int, std::string &gt;</td></tr>
<tr class="separator:acfe4780ebfdd7f66b9fa77a6f0301d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afca147a681e4b39bc471e02d0f07eb37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a> (const <a class="el" href="a02071.html">Node</a> &amp;input_node)</td></tr>
<tr class="memdesc:afca147a681e4b39bc471e02d0f07eb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique ID for this x, y, z position and assign it an new one if it doesn't already exist.  <a href="a01551.html#afca147a681e4b39bc471e02d0f07eb37">More...</a><br /></td></tr>
<tr class="separator:afca147a681e4b39bc471e02d0f07eb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133b6f44ac90ed6135752e32482b70f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a133b6f44ac90ed6135752e32482b70f5">getOrAssignID</a> (int input_int)</td></tr>
<tr class="memdesc:a133b6f44ac90ed6135752e32482b70f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an ID to the graph if it doesn't exist already.  <a href="a01551.html#a133b6f44ac90ed6135752e32482b70f5">More...</a><br /></td></tr>
<tr class="separator:a133b6f44ac90ed6135752e32482b70f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902d654a1c1b6d391c27c6c2bd618bbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a902d654a1c1b6d391c27c6c2bd618bbc">checkForEdge</a> (int parent, int child) const</td></tr>
<tr class="memdesc:a902d654a1c1b6d391c27c6c2bd618bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge between parent and child exists in the graph.  <a href="a01551.html#a902d654a1c1b6d391c27c6c2bd618bbc">More...</a><br /></td></tr>
<tr class="separator:a902d654a1c1b6d391c27c6c2bd618bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8814e293547af636e63e45e400574de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#ab8814e293547af636e63e45e400574de">CSRAddOrUpdateEdge</a> (int parent_id, int child_id, float cost)</td></tr>
<tr class="memdesc:ab8814e293547af636e63e45e400574de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new edge cost to the CSR or update if if a cost already exists.  <a href="a01551.html#ab8814e293547af636e63e45e400574de">More...</a><br /></td></tr>
<tr class="separator:ab8814e293547af636e63e45e400574de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c600a342694552e17cf8705d90163ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a1c600a342694552e17cf8705d90163ef">TripletsAddOrUpdateEdge</a> (int parent_id, int child_id, float cost)</td></tr>
<tr class="memdesc:a1c600a342694552e17cf8705d90163ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new edge to the triplets list.  <a href="a01551.html#a1c600a342694552e17cf8705d90163ef">More...</a><br /></td></tr>
<tr class="separator:a1c600a342694552e17cf8705d90163ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174c4c57d4849cd014ec3b1e9cc474de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a174c4c57d4849cd014ec3b1e9cc474de">ResizeIfNeeded</a> ()</td></tr>
<tr class="memdesc:a174c4c57d4849cd014ec3b1e9cc474de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the CSR to fit all the nodes in ordered_nodes if needed.  <a href="a01551.html#a174c4c57d4849cd014ec3b1e9cc474de">More...</a><br /></td></tr>
<tr class="separator:a174c4c57d4849cd014ec3b1e9cc474de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7fd113e4afe1d0eb01dd23d69b5ecd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#afb7fd113e4afe1d0eb01dd23d69b5ecd">hasKey</a> (int id) const</td></tr>
<tr class="memdesc:afb7fd113e4afe1d0eb01dd23d69b5ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this ID has already been assigned.  <a href="a01551.html#afb7fd113e4afe1d0eb01dd23d69b5ecd">More...</a><br /></td></tr>
<tr class="separator:afb7fd113e4afe1d0eb01dd23d69b5ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d18ac87da28a676ec110d1d9c86b80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a42d18ac87da28a676ec110d1d9c86b80">HasCostArray</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a42d18ac87da28a676ec110d1d9c86b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if we have this edge matrix already defined.  <a href="a01551.html#a42d18ac87da28a676ec110d1d9c86b80">More...</a><br /></td></tr>
<tr class="separator:a42d18ac87da28a676ec110d1d9c86b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27c41b7325344570458ee4953bc3f2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01547.html">EdgeCostSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#ac27c41b7325344570458ee4953bc3f2a">GetCostArray</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:ac27c41b7325344570458ee4953bc3f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the edge matrix at the given key.  <a href="a01551.html#ac27c41b7325344570458ee4953bc3f2a">More...</a><br /></td></tr>
<tr class="separator:ac27c41b7325344570458ee4953bc3f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c1c898465d3ea1b1459e529fd10831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01547.html">EdgeCostSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a83c1c898465d3ea1b1459e529fd10831">GetOrCreateCostType</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a83c1c898465d3ea1b1459e529fd10831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the edge matrix, or create a new one if it doesn't exist.  <a href="a01551.html#a83c1c898465d3ea1b1459e529fd10831">More...</a><br /></td></tr>
<tr class="separator:a83c1c898465d3ea1b1459e529fd10831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe55b81687ef86e24646e19c5eeb771c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01547.html">EdgeCostSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#abe55b81687ef86e24646e19c5eeb771c">CreateCostArray</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:abe55b81687ef86e24646e19c5eeb771c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new edge matrix.  <a href="a01551.html#abe55b81687ef86e24646e19c5eeb771c">More...</a><br /></td></tr>
<tr class="separator:abe55b81687ef86e24646e19c5eeb771c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7154a2f031ebc633aa7d4b4339028d2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01547.html">EdgeCostSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#af7154a2f031ebc633aa7d4b4339028d2">GetCostArray</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:af7154a2f031ebc633aa7d4b4339028d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the edge matrix at the given key.  <a href="a01551.html#af7154a2f031ebc633aa7d4b4339028d2">More...</a><br /></td></tr>
<tr class="separator:af7154a2f031ebc633aa7d4b4339028d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6ed0440c3e83f18dc3c0393a4db63f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a1c6ed0440c3e83f18dc3c0393a4db63f">IsDefaultName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a1c6ed0440c3e83f18dc3c0393a4db63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this name belongs to the default graph.  <a href="a01551.html#a1c6ed0440c3e83f18dc3c0393a4db63f">More...</a><br /></td></tr>
<tr class="separator:a1c6ed0440c3e83f18dc3c0393a4db63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6caefd044805f37078fa7218986cca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#aaa6caefd044805f37078fa7218986cca">FindValueArrayIndex</a> (int parent_id, int child_id) const</td></tr>
<tr class="memdesc:aaa6caefd044805f37078fa7218986cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the cost at parent/child.  <a href="a01551.html#aaa6caefd044805f37078fa7218986cca">More...</a><br /></td></tr>
<tr class="separator:aaa6caefd044805f37078fa7218986cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e5419a528f50749f8c98305f6b4390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#ae4e5419a528f50749f8c98305f6b4390">InsertEdgeIntoCostSet</a> (int parent_id, int child_id, float score, <a class="el" href="a01547.html">EdgeCostSet</a> &amp;cost_set)</td></tr>
<tr class="memdesc:ae4e5419a528f50749f8c98305f6b4390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge to a cost set between parent_id and child_id.  <a href="a01551.html#ae4e5419a528f50749f8c98305f6b4390">More...</a><br /></td></tr>
<tr class="separator:ae4e5419a528f50749f8c98305f6b4390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023c10dad1e62b235f80168ceb71c75a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a023c10dad1e62b235f80168ceb71c75a">InsertEdgesIntoCostSet</a> (<a class="el" href="a01547.html">EdgeCostSet</a> &amp;cost_set, const std::vector&lt; <a class="el" href="a01535.html">EdgeSet</a> &gt; &amp;es)</td></tr>
<tr class="memdesc:a023c10dad1e62b235f80168ceb71c75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert edges for a specific cost type into a cost set.  <a href="a01551.html#a023c10dad1e62b235f80168ceb71c75a">More...</a><br /></td></tr>
<tr class="separator:a023c10dad1e62b235f80168ceb71c75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fd1ad405195ad5455c8bbad34816d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a17fd1ad405195ad5455c8bbad34816d3">InsertOrUpdateEdge</a> (int parent_id, int child_id, float score, const std::string &amp;cost_type)</td></tr>
<tr class="memdesc:a17fd1ad405195ad5455c8bbad34816d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an edge into the default cost array or a new cost array.  <a href="a01551.html#a17fd1ad405195ad5455c8bbad34816d3">More...</a><br /></td></tr>
<tr class="separator:a17fd1ad405195ad5455c8bbad34816d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1106422ecd12416e8931a0e1f4b4fc50"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a1106422ecd12416e8931a0e1f4b4fc50">GetCostForSet</a> (const <a class="el" href="a01547.html">EdgeCostSet</a> &amp;set, int parent_id, int child_id) const</td></tr>
<tr class="memdesc:a1106422ecd12416e8931a0e1f4b4fc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cost of traversing the edge between parent and child using set.  <a href="a01551.html#a1106422ecd12416e8931a0e1f4b4fc50">More...</a><br /></td></tr>
<tr class="separator:a1106422ecd12416e8931a0e1f4b4fc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa143ac9a9e8dbf23fec49a47ca01cdb2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a01527.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#aa143ac9a9e8dbf23fec49a47ca01cdb2">GetEdgesForNode</a> (int parent_id, bool undirected=false, const std::string &amp;cost_type=&quot;&quot;) const</td></tr>
<tr class="memdesc:aa143ac9a9e8dbf23fec49a47ca01cdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges for the given node.  <a href="a01551.html#aa143ac9a9e8dbf23fec49a47ca01cdb2">More...</a><br /></td></tr>
<tr class="separator:aa143ac9a9e8dbf23fec49a47ca01cdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40581bf5c7751041e85e1763697cdb70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00465.html#aaf74b9079d1b97124b8d1e4dae2cc13c">TempMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a40581bf5c7751041e85e1763697cdb70">MapCostMatrix</a> (const std::string &amp;cost_type) const</td></tr>
<tr class="memdesc:a40581bf5c7751041e85e1763697cdb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a temp matrix for the specific cost type.  <a href="a01551.html#a40581bf5c7751041e85e1763697cdb70">More...</a><br /></td></tr>
<tr class="separator:a40581bf5c7751041e85e1763697cdb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f23c075c3a912a5c12b8d243f15f70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a42f23c075c3a912a5c12b8d243f15f70">HasNodeAttribute</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a42f23c075c3a912a5c12b8d243f15f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this graph has a specific node attribute.  <a href="a01551.html#a42f23c075c3a912a5c12b8d243f15f70">More...</a><br /></td></tr>
<tr class="separator:a42f23c075c3a912a5c12b8d243f15f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aaab13304c641df6fdcd3662d5c54dc78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#aaab13304c641df6fdcd3662d5c54dc78">next_id</a> = 0</td></tr>
<tr class="memdesc:aaab13304c641df6fdcd3662d5c54dc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id for the next unique node.  <a href="a01551.html#aaab13304c641df6fdcd3662d5c54dc78">More...</a><br /></td></tr>
<tr class="separator:aaab13304c641df6fdcd3662d5c54dc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59ab7164b64e3d78b7032b28c2c6663"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a02071.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#ad59ab7164b64e3d78b7032b28c2c6663">ordered_nodes</a></td></tr>
<tr class="memdesc:ad59ab7164b64e3d78b7032b28c2c6663"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of nodes contained by the graph.  <a href="a01551.html#ad59ab7164b64e3d78b7032b28c2c6663">More...</a><br /></td></tr>
<tr class="separator:ad59ab7164b64e3d78b7032b28c2c6663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da5e288f03773d18053c82731369b2a"><td class="memItemLeft" align="right" valign="top">robin_hood::unordered_map&lt; <a class="el" href="a02071.html">Node</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a4da5e288f03773d18053c82731369b2a">idmap</a></td></tr>
<tr class="memdesc:a4da5e288f03773d18053c82731369b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a list of X,Y,Z positions to positions in ordered_nodes.  <a href="a01551.html#a4da5e288f03773d18053c82731369b2a">More...</a><br /></td></tr>
<tr class="separator:a4da5e288f03773d18053c82731369b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf07c256da74c2a03f81b4977364e85"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Triplet&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a1cf07c256da74c2a03f81b4977364e85">triplets</a></td></tr>
<tr class="memdesc:a1cf07c256da74c2a03f81b4977364e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edges to be converted to a CSR when <a class="el" href="a01551.html#a41cece77d0eee98df39ecc6d3a366ec8" title="Compress the graph to a CSR and enable the usage of several functions.">Graph::Compress()</a> is called.  <a href="a01551.html#a1cf07c256da74c2a03f81b4977364e85">More...</a><br /></td></tr>
<tr class="separator:a1cf07c256da74c2a03f81b4977364e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbd600663187d7cf985e9b6e7cea73f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a1cbd600663187d7cf985e9b6e7cea73f">needs_compression</a> = true</td></tr>
<tr class="memdesc:a1cbd600663187d7cf985e9b6e7cea73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, the CSR is inaccurate and requires compression.  <a href="a01551.html#a1cbd600663187d7cf985e9b6e7cea73f">More...</a><br /></td></tr>
<tr class="separator:a1cbd600663187d7cf985e9b6e7cea73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec76d5e193267be65a42eb1794a3abb"><td class="memItemLeft" align="right" valign="top">robin_hood::unordered_map&lt; std::string, <a class="el" href="a01551.html#acfe4780ebfdd7f66b9fa77a6f0301d52">NodeAttributeValueMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#aeec76d5e193267be65a42eb1794a3abb">node_attr_map</a></td></tr>
<tr class="memdesc:aeec76d5e193267be65a42eb1794a3abb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02071.html" title="A point in space with an ID.">Node</a> attribute type : Map of node id to node attribute.  <a href="a01551.html#aeec76d5e193267be65a42eb1794a3abb">More...</a><br /></td></tr>
<tr class="separator:aeec76d5e193267be65a42eb1794a3abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aed491dde212682fe65e248114371b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a73aed491dde212682fe65e248114371b">active_cost_type</a></td></tr>
<tr class="memdesc:a73aed491dde212682fe65e248114371b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The active edge matrix to use for the graph.  <a href="a01551.html#a73aed491dde212682fe65e248114371b">More...</a><br /></td></tr>
<tr class="separator:a73aed491dde212682fe65e248114371b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be5d62e01eabe7e1581d238cfb35ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00465.html#a40b235356dfcdd3f2e1adc0f3c342007">EdgeMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a0be5d62e01eabe7e1581d238cfb35ace">edge_matrix</a></td></tr>
<tr class="memdesc:a0be5d62e01eabe7e1581d238cfb35ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying CSR containing edge information.  <a href="a01551.html#a0be5d62e01eabe7e1581d238cfb35ace">More...</a><br /></td></tr>
<tr class="separator:a0be5d62e01eabe7e1581d238cfb35ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba19080a765d7a09b0acbf8ffdcd1277"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#aba19080a765d7a09b0acbf8ffdcd1277">default_cost</a> = &quot;Distance&quot;</td></tr>
<tr class="separator:aba19080a765d7a09b0acbf8ffdcd1277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db3f8505fa2e7a4a54060fede1770f6"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="a01547.html">EdgeCostSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a4db3f8505fa2e7a4a54060fede1770f6">edge_cost_maps</a></td></tr>
<tr class="memdesc:a4db3f8505fa2e7a4a54060fede1770f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; The default cost type of the graph.  <a href="a01551.html#a4db3f8505fa2e7a4a54060fede1770f6">More...</a><br /></td></tr>
<tr class="separator:a4db3f8505fa2e7a4a54060fede1770f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0415ae8030d4c524f91538737155413"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#aa0415ae8030d4c524f91538737155413">has_cost_arrays</a> = false</td></tr>
<tr class="memdesc:aa0415ae8030d4c524f91538737155413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the graph has cost arrays.  <a href="a01551.html#aa0415ae8030d4c524f91538737155413">More...</a><br /></td></tr>
<tr class="separator:aa0415ae8030d4c524f91538737155413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4330f0c85299f975495124514354b271"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01551.html#a4330f0c85299f975495124514354b271">nodes_out_of_order</a> = false</td></tr>
<tr class="memdesc:a4330f0c85299f975495124514354b271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the graph is using integer nodes.  <a href="a01551.html#a4330f0c85299f975495124514354b271">More...</a><br /></td></tr>
<tr class="separator:a4330f0c85299f975495124514354b271"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A <a class="el" href="a01551.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">Graph</a> of nodes connected by edges that supports both integers and <a class="el" href="a02071.html" title="A point in space with an ID.">HF::SpatialStructures::Node</a>. </p>
<p >Internally, this object uses <a class="el" href="a00471.html" title="Eigen a C++ template library for linear algebra: matrices, vectors, numerical solvers,...">Eigen</a> (<a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a>) to store and maintain a CSR matrix. The CSR is always stored as a n by n sparse matrix where n is the number of nodes in ordered_nodes.</p>
<dl class="section user"><dt>Cost Types</dt><dd>This <a class="el" href="a01551.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">Graph</a> is capable of holding multiple cost types for any of it's edges. Each cost type has a distinct key as it's name, such as "CrossSlope" or "EnergyExpenditure". Upon creation, the graph is assigned a default cost type, <code>Distance</code> which can be accessed explicitly by the key "Distance" or leaving the cost_type field blank. Alternate costs have corresponding edges in the default cost set, but different costs to traverse from the parent to the child node.</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>1) Every node in the graph will have a Unique ID with no repeats </dd>
<dd>
2) Any edge cost set will be a valid replacement for CSR's values array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00486">486</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acfe4780ebfdd7f66b9fa77a6f0301d52" name="acfe4780ebfdd7f66b9fa77a6f0301d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe4780ebfdd7f66b9fa77a6f0301d52">&#9670;&#160;</a></span>NodeAttributeValueMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a01551.html#acfe4780ebfdd7f66b9fa77a6f0301d52">HF::SpatialStructures::Graph::NodeAttributeValueMap</a> =  robin_hood::unordered_map&lt;int, std::string&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00487">487</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a738bbf6e1d4d8eefd9884e7d117d4ef5" name="a738bbf6e1d4d8eefd9884e7d117d4ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738bbf6e1d4d8eefd9884e7d117d4ef5">&#9670;&#160;</a></span>Graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HF::SpatialStructures::Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a02071.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_cost</em> = <code>&quot;Distance&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a graph from a list of nodes, edges, and distances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>Ordered array of arrays of edges for each node in nodes. </td></tr>
    <tr><td class="paramname">distances</td><td>Ordered array of distance from parent to child for each edge in edges. </td></tr>
    <tr><td class="paramname">Nodes</td><td>Ordered array of nodes to act as a parent to all children in it's array in edges. </td></tr>
    <tr><td class="paramname">default_cost</td><td>Default cost of the graph. This is the name of the first used cost.</td></tr>
  </table>
  </dd>
</dl>
<p>Preallocates the matrix it in element by element and compresses it.</p>
<dl class="section pre"><dt>Precondition</dt><dd>1) The size of all input arrays must match: <code>(edges.size() == nodes.size() &amp;&amp; nodes.size() == distances.size())</code></dd>
<dd>
2) For the node at <code>nodes[i]</code>, <code>edges[i]</code> should contain an array for the id of all nodes that <code>nodes[i]</code> has an edge from and, and <code>distances[i]</code> should contain an array of the the distance from <code>nodes[i]</code> to one of the nodes it has an edge to in <code>edges[i]</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After constructing a graph with this constructor, it will not be able to be modified. Use the empty constructor and use addEdge if you want to modify the graph after construction. This may change in the future.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This constructor can offer "slightly higher performance and memory consumption" than constructing a graph using <a class="el" href="a01551.html#a37be5c12e488072dea7fa1c8c64346f7" title="Add a new edge to the graph from parent to child.">Graph::addEdge</a> in a loop according to official eigen documentation, however it may not be feasible for certain situations where the entire graph isn't known before the constructor is called. The implementation is based on the algorithm from <a class="el" href="a00471.html" title="Eigen a C++ template library for linear algebra: matrices, vectors, numerical solvers,...">Eigen</a>'s documentation under the section Filling a Sparse Matrix <a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line"> </div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="ttc" id="aa01551_html"><div class="ttname"><a href="a01551.html">HF::SpatialStructures::Graph</a></div><div class="ttdoc">A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.</div><div class="ttdef"><b>Definition:</b> <a href="a00269_source.html#l00486">graph.h:486</a></div></div>
<div class="ttc" id="aa02071_html"><div class="ttname"><a href="a02071.html">HF::SpatialStructures::Node</a></div><div class="ttdoc">A point in space with an ID.</div><div class="ttdef"><b>Definition:</b> <a href="a00275_source.html#l00038">node.h:38</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2386d87722e4459b70dc2995a7bf2be4" name="a2386d87722e4459b70dc2995a7bf2be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2386d87722e4459b70dc2995a7bf2be4">&#9670;&#160;</a></span>Graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HF::SpatialStructures::Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_cost_name</em> = <code>&quot;Distance&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty graph. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This can be used to create a new graph to later be filled with edges/nodes by calling <a class="el" href="a01551.html#a37be5c12e488072dea7fa1c8c64346f7" title="Add a new edge to the graph from parent to child.">Graph::addEdge()</a> then calling <a class="el" href="a01551.html#a41cece77d0eee98df39ecc6d3a366ec8" title="Compress the graph to a CSR and enable the usage of several functions.">Graph::Compress()</a>. Implementation is based on the <a class="el" href="a00471.html" title="Eigen a C++ template library for linear algebra: matrices, vectors, numerical solvers,...">Eigen</a> documentation for Filling a CSR: <a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01551.html#a37be5c12e488072dea7fa1c8c64346f7" title="Add a new edge to the graph from parent to child.">Graph::addEdge()</a> for details on adding edges. </dd>
<dd>
<a class="el" href="a01551.html#a41cece77d0eee98df39ecc6d3a366ec8" title="Compress the graph to a CSR and enable the usage of several functions.">Graph::Compress()</a> for details on compressing the graph.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph;     <span class="comment">// This represents an order-zero graph (null graph)</span></div>
<div class="line">                                        <span class="comment">// It lacks vertices and edges.</span></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a37be5c12e488072dea7fa1c8c64346f7" name="a37be5c12e488072dea7fa1c8c64346f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37be5c12e488072dea7fa1c8c64346f7">&#9670;&#160;</a></span>addEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>score</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new edge to the graph from parent to child.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent node of the edge. </td></tr>
    <tr><td class="paramname">child</td><td>Child node of the edge. </td></tr>
    <tr><td class="paramname">score</td><td>Cost of traversing from aprent to child. </td></tr>
  </table>
  </dd>
</dl>
<p >If the parent or child node do not have an ID. An ID will be assigned automatically.</p>
<dl class="section warning"><dt>Warning</dt><dd>This will not work if the graph wasn't created from the empty constructor since it has no internal edge list to add to.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This adds a new element to the triplet list so next time Compress is called, the value is added to the graph.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00452.html#_todo000026">Todo:</a></b></dt><dd>How should this signal that the graph can't have edges added to it? Or how do we add edges to an existing graph quickly without adding to its edge list?</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a pair of nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> n_parent(4.0f, 5.0f, 6.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> n_child(7.0f, 8.0f, 9.0f);</div>
<div class="line"> </div>
<div class="line">graph.addEdge(n_parent, n_child);   <span class="comment">// default score is 1.0f</span></div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00170">AddEdgeFromNodeIDs()</a>, <a class="el" href="a00434_source.html#l00135">AddEdgeFromNodes()</a>, <a class="el" href="a00005_source.html#l00222">HF::GraphGenerator::GraphGenerator::CrawlGeom()</a>, and <a class="el" href="a00005_source.html#l00141">HF::GraphGenerator::GraphGenerator::CrawlGeomParallel()</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a37be5c12e488072dea7fa1c8c64346f7_icgraph.svg" width="1079" height="238"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0584ab845d5c21979b1542651a4cf3aa" name="a0584ab845d5c21979b1542651a4cf3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0584ab845d5c21979b1542651a4cf3aa">&#9670;&#160;</a></span>addEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new edge to the graph from parent to child.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent node of the edge. </td></tr>
    <tr><td class="paramname">child</td><td>Child node of the edge. </td></tr>
    <tr><td class="paramname">score</td><td>Cost of traversing from aprent to child. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost_type</td><td>Type of cost to add this edge to</td></tr>
  </table>
  </dd>
</dl>
<p>If the parent or child ids don't exist in the dictionary, they will be added.</p>
<dl class="section warning"><dt>Warning</dt><dd>This will not work if the graph wasn't created from the empty constructor since it has no internal edge list to add to.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This adds a new element to the triplet list so next time Compress is called, the value is added to the graph. (Note: if an edge exists between parent_id and child_id, the score value will be added to the existing score value for the edge formed by parent_id and child_id).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>Tried to add an edge to an alternate cost type when the graph isnt compressed </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>Tried to add an edge to an alternate cost type when it hasn't been added to the default graph</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="a00452.html#_todo000027">Todo:</a></b></dt><dd>How should this signal that the graph can't have edges added to it? Or how do we add edges to an existing graph quickly without adding to its edge list?</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> parent = 1;</div>
<div class="line"><span class="keywordtype">int</span> child = 2;</div>
<div class="line"> </div>
<div class="line">graph.addEdge(parent, child, 1.0f);</div>
<div class="line">graph.Compress();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6f04c5320d4bf88120f8c5e31b0fb02a" name="a6f04c5320d4bf88120f8c5e31b0fb02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f04c5320d4bf88120f8c5e31b0fb02a">&#9670;&#160;</a></span>AddEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::AddEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01535.html">EdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add multiple edges to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The set of edges to add to the graph </td></tr>
    <tr><td class="paramname">cost_name</td><td>The cost_type to add the edges to. If this cost type doesn't exist in the graph yet, then it will be created. If left blank or set to the default name, then the edges will be added to the default cost type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) If adding edges to an alternate cost type, the edges must already have been added to the default graph. </dd>
<dd>
2) If adding an alternate edge to the graph, the graph must already be compressed</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>Trying to add an edge to an alternate cost type when it's not compressed </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>Trying to add an edge to an alternate cost type when it hasn't already been added to the default graph2) If adding an alternate edge to the graph, the graph must already be compressed </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00381">CalculateAndStoreCrossSlope()</a>, and <a class="el" href="a00434_source.html#l00273">CalculateAndStoreEnergyExpenditure()</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a6f04c5320d4bf88120f8c5e31b0fb02a_icgraph.svg" width="444" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4fb7f82bbc403885c378d0896c742443" name="a4fb7f82bbc403885c378d0896c742443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb7f82bbc403885c378d0896c742443">&#9670;&#160;</a></span>AddEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::AddEdges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a01535.html">EdgeSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an array of edges to the graph. </p>

</div>
</div>
<a id="a819ecd54d0148ddf867e6ca77fec8379" name="a819ecd54d0148ddf867e6ca77fec8379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819ecd54d0148ddf867e6ca77fec8379">&#9670;&#160;</a></span>AddNodeAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::AddNodeAttribute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an attribute to the node at id  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the node that will receive attribute </td></tr>
    <tr><td class="paramname">attribute</td><td>The attribute that the node at ID will receive </td></tr>
    <tr><td class="paramname">score</td><td>The weight, or distance that extends from the node at id </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a306a0277ba1caa0aa4a1227e2f847f09" name="a306a0277ba1caa0aa4a1227e2f847f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306a0277ba1caa0aa4a1227e2f847f09">&#9670;&#160;</a></span>AddNodeAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::AddNodeAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>scores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an attribute to the node at id. If the node at id already has a score for the attribute at name, then existing score should be overwritten  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The container of IDs from which nodes will be retrieved and given attributes </td></tr>
    <tr><td class="paramname">name</td><td>The attribute that each node will receive </td></tr>
    <tr><td class="paramname">scores</td><td>The container of score, ordered by the container of node IDs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The length of ids, and the length of scores must be equal </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>The length of scores and the length of ID do not match.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00290">AddNodeAttributes()</a>.</p>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a306a0277ba1caa0aa4a1227e2f847f09_icgraph.svg" width="371" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a487b0b29dc7c554089e0255779218567" name="a487b0b29dc7c554089e0255779218567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487b0b29dc7c554089e0255779218567">&#9670;&#160;</a></span>AggregateGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; HF::SpatialStructures::Graph::AggregateGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00465.html#a6b23c0b2531c78f6d5049873c184f4f9">COST_AGGREGATE</a>&#160;</td>
          <td class="paramname"><em>agg_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Summarize the costs of every outgoing edge for every node in the graph.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agg_type</td><td>Type of aggregation to use. </td></tr>
    <tr><td class="paramname">directed</td><td>If true, include both incoming and outgoing edges for calculating a node's score. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An ordered list of scores for agg_type on each node in the graph. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Useful for getting scores from the <a class="el" href="a00467.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if agg_type doesn't match any value of COST_AGGREGATE. </td></tr>
    <tr><td class="paramname">Std::exception</td><td>if the graph isn't compressed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time Complexity</dt><dd>If undirected: <code>O(k)</code> where k is the total number of edges in the graph.<br  />
If directed: <code>O(n)</code> where n is the total number of nodes in the graph.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00465.html#a6b23c0b2531c78f6d5049873c184f4f9" title="Methods of aggregating the costs for edges for each node in the graph.">COST_AGGREGATE</a> to see a list of supported aggregation types. <div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// graph must be compressed, or a exception will be thrown</span></div>
<div class="line"><a class="code hl_enumeration" href="a00465.html#a6b23c0b2531c78f6d5049873c184f4f9">HF::SpatialStructures::COST_AGGREGATE</a> aggregate = <a class="code hl_enumvalue" href="a00465.html#a6b23c0b2531c78f6d5049873c184f4f9a16de38737a9f8366e9b2042b4e9b6290">HF::SpatialStructures::COST_AGGREGATE::AVERAGE</a>;       <span class="comment">// aggregate == 1 in this case</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// directed parameter may be true or false</span></div>
<div class="line">std::vector&lt;float&gt; aggregate_graph = graph.AggregateGraph(aggregate, <span class="keyword">true</span>);</div>
<div class="ttc" id="aa00465_html_a6b23c0b2531c78f6d5049873c184f4f9"><div class="ttname"><a href="a00465.html#a6b23c0b2531c78f6d5049873c184f4f9">HF::SpatialStructures::COST_AGGREGATE</a></div><div class="ttdeci">COST_AGGREGATE</div><div class="ttdoc">Methods of aggregating the costs for edges for each node in the graph.</div><div class="ttdef"><b>Definition:</b> <a href="a00269_source.html#l00028">graph.h:28</a></div></div>
<div class="ttc" id="aa00465_html_a6b23c0b2531c78f6d5049873c184f4f9a16de38737a9f8366e9b2042b4e9b6290"><div class="ttname"><a href="a00465.html#a6b23c0b2531c78f6d5049873c184f4f9a16de38737a9f8366e9b2042b4e9b6290">HF::SpatialStructures::COST_AGGREGATE::AVERAGE</a></div><div class="ttdeci">@ AVERAGE</div><div class="ttdoc">Average the cost of all edges.</div></div>
</div><!-- fragment --> </dd></dl>

<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00094">AggregateCosts()</a>.</p>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a487b0b29dc7c554089e0255779218567_icgraph.svg" width="340" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acb6e9bc04bec84b28043c41c96139b1a" name="acb6e9bc04bec84b28043c41c96139b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6e9bc04bec84b28043c41c96139b1a">&#9670;&#160;</a></span>AttrToCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::AttrToCost </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_to_store_as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00465.html#afac7c4ef1cb1104941f4d5a27973b47e">Direction</a>&#160;</td>
          <td class="paramname"><em>consider</em> = <code><a class="el" href="a00465.html#afac7c4ef1cb1104941f4d5a27973b47eafb4081bff9f77d65456ceb00b153e4d4">Direction::INCOMING</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate edge costs from a set of node attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr_key</td><td>Attribute to create a new cost set from. </td></tr>
    <tr><td class="paramname">cost_string</td><td>Name of the new cost set. </td></tr>
    <tr><td class="paramname">dir</td><td>Direction that the cost of the edge should be calculated in. For example INCOMING will use the cost of the node being traveled to by the edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>node_attribute</code> could not be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> </div>
<div class="line">    <span class="comment">// Define nodes</span></div>
<div class="line">    <span class="keyword">const</span> vector&lt;Node&gt; <a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a> = {</div>
<div class="line">        {1,1,1}, {2,2,2}, {3,3,3},{4,4,4}, {5,5,5}</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define the graph, compress it then add edges</span></div>
<div class="line">    <a class="code hl_function" href="a01551.html#a738bbf6e1d4d8eefd9884e7d117d4ef5">Graph</a> G;</div>
<div class="line">    G.addEdge(<a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[0], <a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[2], 2);</div>
<div class="line">    G.addEdge(<a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[0], <a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[1], 1);</div>
<div class="line">    G.addEdge(<a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[3], <a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[0], 3);</div>
<div class="line">    G.addEdge(<a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[2], <a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[1], 4);</div>
<div class="line">    G.addEdge(<a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[0], <a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[4], 555);</div>
<div class="line">    G.Compress();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get the ids of every node since the graph assigns them</span></div>
<div class="line">    std::vector&lt;int&gt; ids(<a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>.size(), -1);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>.size(); i++)</div>
<div class="line">        ids[i] = G.getID(<a class="code hl_function" href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">Nodes</a>[i]);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create node attributes</span></div>
<div class="line">    G.AddNodeAttribute(ids[0], test_attribute, <span class="stringliteral">&quot;000&quot;</span>);</div>
<div class="line">    G.AddNodeAttribute(ids[1], test_attribute, <span class="stringliteral">&quot;111&quot;</span>);</div>
<div class="line">    G.AddNodeAttribute(ids[2], test_attribute, <span class="stringliteral">&quot;222&quot;</span>);</div>
<div class="line">    G.AddNodeAttribute(ids[3], test_attribute, <span class="stringliteral">&quot;333&quot;</span>);</div>
<div class="line">    </div>
<div class="ttc" id="aa01551_html_a738bbf6e1d4d8eefd9884e7d117d4ef5"><div class="ttname"><a href="a01551.html#a738bbf6e1d4d8eefd9884e7d117d4ef5">HF::SpatialStructures::Graph::Graph</a></div><div class="ttdeci">Graph(const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;edges, const std::vector&lt; std::vector&lt; float &gt; &gt; &amp;distances, const std::vector&lt; Node &gt; &amp;Nodes, const std::string &amp;default_cost=&quot;Distance&quot;)</div><div class="ttdoc">Construct a graph from a list of nodes, edges, and distances.</div></div>
<div class="ttc" id="aa01551_html_aa70347b8a33b57c6f0a72d6eca4248d7"><div class="ttname"><a href="a01551.html#aa70347b8a33b57c6f0a72d6eca4248d7">HF::SpatialStructures::Graph::Nodes</a></div><div class="ttdeci">std::vector&lt; Node &gt; Nodes() const</div><div class="ttdoc">Get a list of nodes from the graph sorted by ID.</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"> </div>
<div class="line">    <span class="comment">// Convert node attributes to graph costs based on the cost of the child node</span></div>
<div class="line">    G.AttrToCost(test_attribute, <span class="stringliteral">&quot;output_str&quot;</span>, <a class="code hl_enumvalue" href="a00465.html#afac7c4ef1cb1104941f4d5a27973b47eafb4081bff9f77d65456ceb00b153e4d4">Direction::INCOMING</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Print out the cost of edge 3 to 0</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;0-&gt;1: %f\n&quot;</span>, G.GetCost(ids[0], ids[1], <span class="stringliteral">&quot;output_str&quot;</span>));</div>
<div class="line"> </div>
<div class="ttc" id="aa00465_html_afac7c4ef1cb1104941f4d5a27973b47eafb4081bff9f77d65456ceb00b153e4d4"><div class="ttname"><a href="a00465.html#afac7c4ef1cb1104941f4d5a27973b47eafb4081bff9f77d65456ceb00b153e4d4">HF::SpatialStructures::Direction::INCOMING</a></div><div class="ttdeci">@ INCOMING</div></div>
</div><!-- fragment --> <code>0-&gt;1: 111.000000</code> </dd></dl>

<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00405">GraphAttrsToCosts()</a>.</p>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_acb6e9bc04bec84b28043c41c96139b1a_icgraph.svg" width="338" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a902d654a1c1b6d391c27c6c2bd618bbc" name="a902d654a1c1b6d391c27c6c2bd618bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902d654a1c1b6d391c27c6c2bd618bbc">&#9670;&#160;</a></span>checkForEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::checkForEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if an edge between parent and child exists in the graph. </p>
<p >Iterates through every row in the parent's column to find child. If child is not found in this column, false is returned. If child can be found in this column, then true is returned.</p>
<dl class="section user"><dt>Time Complexity</dt><dd>O(k) where k is the number of edges from parent. <div class="fragment"><div class="line">        </div>
<div class="line">        <span class="comment">// Get the index for parent and child</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> parent_index = parent;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> child_index = child;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If the parent is not even in the graph, or the graph doesn&#39;t have any zeros, return early. </span></div>
<div class="line">        <span class="comment">// Calling the iterator in both of these cases is undefined behavior and should be avoided</span></div>
<div class="line">        <span class="keywordflow">if</span> (!IsInRange(<a class="code hl_variable" href="a01551.html#a0be5d62e01eabe7e1581d238cfb35ace">edge_matrix</a>.nonZeros(), <a class="code hl_variable" href="a01551.html#a0be5d62e01eabe7e1581d238cfb35ace">edge_matrix</a>.rows(), parent)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <span class="comment">//  if (edge_matrix.nonZeros() &lt;= 0 || edge_matrix.rows() &lt;= parent) return false;</span></div>
<div class="line">    </div>
<div class="line">        <span class="comment">// Iterate through parent&#39;s row to see if it has child.</span></div>
<div class="line">        <span class="keywordflow">for</span> (EdgeMatrix::InnerIterator it(<a class="code hl_variable" href="a01551.html#a0be5d62e01eabe7e1581d238cfb35ace">edge_matrix</a>, parent_index); it; ++it) {</div>
<div class="line">            <span class="keywordflow">if</span> (it.col() == child_index) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// If we&#39;ve gotten to this point, then the child doesn&#39;t exist in parent&#39;s row</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="ttc" id="aa01551_html_a0be5d62e01eabe7e1581d238cfb35ace"><div class="ttname"><a href="a01551.html#a0be5d62e01eabe7e1581d238cfb35ace">HF::SpatialStructures::Graph::edge_matrix</a></div><div class="ttdeci">EdgeMatrix edge_matrix</div><div class="ttdoc">The underlying CSR containing edge information.</div><div class="ttdef"><b>Definition:</b> <a href="a00269_source.html#l00502">graph.h:502</a></div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a994dbd15119eb6548d2e15f4de4b88a6" name="a994dbd15119eb6548d2e15f4de4b88a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994dbd15119eb6548d2e15f4de4b88a6">&#9670;&#160;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all nodes and edges from the graph.  </p>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If we want to remove all nodes and edges from graph, we may do so with Clear:</span></div>
<div class="line">graph.Clear();                      <span class="comment">// active_edge_matrix is zeroed out, buffer is squeezed,</span></div>
<div class="line">                                    <span class="comment">// triplets are also cleared, and</span></div>
<div class="line">                                    <span class="comment">// needs_compression == true</span></div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00234">ClearGraph()</a>.</p>
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a994dbd15119eb6548d2e15f4de4b88a6_icgraph.svg" width="292" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8f51b29e611c7bb59a0f4242d6e01c73" name="a8f51b29e611c7bb59a0f4242d6e01c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f51b29e611c7bb59a0f4242d6e01c73">&#9670;&#160;</a></span>ClearCostArrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::ClearCostArrays </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear one or more cost arrays from the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost_name</td><td>Name of the cost array to clear. If equal to the default cost of this graph or empty string, will clear all existing cost arrays (except for the default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NoCost</td><td>if the costname specified not match either the default cost or any other cost type held by the graph. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00234">ClearGraph()</a>.</p>
<div id="dynsection-7" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-7-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a8f51b29e611c7bb59a0f4242d6e01c73_icgraph.svg" width="312" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0279f117df3d0d29d0a06301dac146a9" name="a0279f117df3d0d29d0a06301dac146a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0279f117df3d0d29d0a06301dac146a9">&#9670;&#160;</a></span>ClearNodeAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::ClearNodeAttributes </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the attribute at name and all of its contents from the internal hashmap  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The attribute that will be cleared from this graph's internal hashmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td></td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00368">ClearAttributeType()</a>.</p>
<div id="dynsection-8" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-8-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-8-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-8-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a0279f117df3d0d29d0a06301dac146a9_icgraph.svg" width="376" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a41cece77d0eee98df39ecc6d3a366ec8" name="a41cece77d0eee98df39ecc6d3a366ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cece77d0eee98df39ecc6d3a366ec8">&#9670;&#160;</a></span>Compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::Compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress the graph to a CSR and enable the usage of several functions. </p>
<p >This won't do anything if called on an already compressed graph. The graph is "compressed" by resizing the edge matrix to the maximum ID of any node in triplets, then calling setFromTriplets().</p>
<dl class="section note"><dt>Note</dt><dd>This function actually doesn't actually reduce memory usage since it keeps the edge list in order to allow for modifications to the graph. In the future, it may be beneficial allow for the user to pass in a boolean that would delete the triplet array if true.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method of constructing the CSR is based on <a class="el" href="a00471.html" title="Eigen a C++ template library for linear algebra: matrices, vectors, numerical solvers,...">Eigen</a>'s documentation for Filling a sparse matrix <a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a pair of nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> n_parent(4.0f, 5.0f, 6.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> n_child(7.0f, 8.0f, 9.0f);</div>
<div class="line"> </div>
<div class="line">graph.addEdge(n_parent, n_child);   <span class="comment">// default score is 1.0f</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// In order to use GetEdges, or AggregateGraph, we must compress our graph instance</span></div>
<div class="line">graph.Compress();                       <span class="comment">// GetEdges and AggregateGraph are now usable</span></div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00228">Compress()</a>.</p>
<div id="dynsection-9" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-9-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-9-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-9-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a41cece77d0eee98df39ecc6d3a366ec8_icgraph.svg" width="286" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abe55b81687ef86e24646e19c5eeb771c" name="abe55b81687ef86e24646e19c5eeb771c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe55b81687ef86e24646e19c5eeb771c">&#9670;&#160;</a></span>CreateCostArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01547.html">EdgeCostSet</a> &amp; HF::SpatialStructures::Graph::CreateCostArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new edge matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Unique name of the new cost array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the new edge cost set</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) <code>name</code> does not already belong to another cost array in the graph. </dd>
<dd>
2) <code>name</code> is not the default name in the graph or an empty string. </dd></dl>

</div>
</div>
<a id="ab8814e293547af636e63e45e400574de" name="ab8814e293547af636e63e45e400574de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8814e293547af636e63e45e400574de">&#9670;&#160;</a></span>CSRAddOrUpdateEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::CSRAddOrUpdateEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new edge cost to the CSR or update if if a cost already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td>ID of the parent node. </td></tr>
    <tr><td class="paramname">child_id</td><td>ID of the child node </td></tr>
    <tr><td class="paramname">cost</td><td>Cost of traversing from parent to child</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is called when the graph is compressed and the user tries to add a new edge.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>parent_id and child_id point to valid nodes in the graph.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This will invalidate any EdgeCostSets. Don't call this if you have edge cost sets. </dd></dl>

</div>
</div>
<a id="a0a73ceca4e8c54b18c6bba02e0a129ed" name="a0a73ceca4e8c54b18c6bba02e0a129ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a73ceca4e8c54b18c6bba02e0a129ed">&#9670;&#160;</a></span>DumpToJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::DumpToJson </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa6caefd044805f37078fa7218986cca" name="aaa6caefd044805f37078fa7218986cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6caefd044805f37078fa7218986cca">&#9670;&#160;</a></span>FindValueArrayIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::FindValueArrayIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the cost at parent/child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td>ID of the edge's parent. </td></tr>
    <tr><td class="paramname">child_id</td><td>ID of the edge's child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if there is no edge between parent and child. Otherwise returns the index in the values array that belongs to the cost of traversing from parent to child.</dd></dl>
<p>Determines the start and end bounds of the row belonging to <code>parent_id</code> using the CSR's outer_index_ptr, then searches these bounds in inner_indices for <code>child_id</code>. If a match is found, the distance from child_id to the beginning of the csr's inner_index array is calculated and returned.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This is used in several places to index EdgeCostSets.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>parent_id</code> is a valid node in the graph. </dd></dl>

</div>
</div>
<a id="a5b73c72a75c16e9565387d3bf391430f" name="a5b73c72a75c16e9565387d3bf391430f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b73c72a75c16e9565387d3bf391430f">&#9670;&#160;</a></span>GetChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a02071.html">Node</a> &gt; HF::SpatialStructures::Graph::GetChildren </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>parent_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve node parent_id's child nodes  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td>The parent node ID from which child nodes will be derived </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container of child nodes that form edges that extend from node parent_id </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae8abc9a6de7add5c18492fdd5d8b2066" name="ae8abc9a6de7add5c18492fdd5d8b2066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8abc9a6de7add5c18492fdd5d8b2066">&#9670;&#160;</a></span>GetChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a02071.html">Node</a> &gt; HF::SpatialStructures::Graph::GetChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve n's child nodes - n is a parent node  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The parent node from which child nodes will be derived </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container of child nodes that form edges that extend from parent node n </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2bb134f68f988eeee4e0ba3e2a698852" name="a2bb134f68f988eeee4e0ba3e2a698852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb134f68f988eeee4e0ba3e2a698852">&#9670;&#160;</a></span>GetCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float HF::SpatialStructures::Graph::GetCost </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the cost from parent_id to child_id in the given cost_type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td><a class="el" href="a02071.html" title="A point in space with an ID.">Node</a> that's being traversed from. </td></tr>
    <tr><td class="paramname">child_id</td><td><a class="el" href="a02071.html" title="A point in space with an ID.">Node</a> that's being traversed to. </td></tr>
    <tr><td class="paramname">cost_type</td><td>Type of cost to get for this edge. If blank, the graph's default cost type will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of traversing from <code>parent_id</code> to <code>child_id</code> for <code>cost_type</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>cost_type must be the name of a cost that already exists in the graph, or blank. </dd></dl>

<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00066">GetEdgeCost()</a>.</p>
<div id="dynsection-10" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-10-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-10-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-10-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a2bb134f68f988eeee4e0ba3e2a698852_icgraph.svg" width="304" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ac27c41b7325344570458ee4953bc3f2a" name="ac27c41b7325344570458ee4953bc3f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27c41b7325344570458ee4953bc3f2a">&#9670;&#160;</a></span>GetCostArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01547.html">EdgeCostSet</a> &amp; HF::SpatialStructures::Graph::GetCostArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the edge matrix at the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Name of the cost to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The EdgeCostArray with the name of <code>key</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a01335.html" title="Thrown when a dependency is missing such as Embree.">HF::Exceptions::NoCost</a></td><td>if the given key doesn't exist</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>key</code> is not the default graph name or an empty string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01551.html#a42d18ac87da28a676ec110d1d9c86b80" title="Check if we have this edge matrix already defined.">HasCostArray</a> for a way of checking that the cost type exists before calling in situations where throwing is not possible, or unwanted. </dd></dl>

</div>
</div>
<a id="af7154a2f031ebc633aa7d4b4339028d2" name="af7154a2f031ebc633aa7d4b4339028d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7154a2f031ebc633aa7d4b4339028d2">&#9670;&#160;</a></span>GetCostArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01547.html">EdgeCostSet</a> &amp; HF::SpatialStructures::Graph::GetCostArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the edge matrix at the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Name of the cost to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The EdgeCostArray with the name of <code>key</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a01335.html" title="Thrown when a dependency is missing such as Embree.">HF::Exceptions::NoCost</a></td><td>if the given cost doesn't exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01551.html#a42d18ac87da28a676ec110d1d9c86b80" title="Check if we have this edge matrix already defined.">HasCostArray</a> for a way of checking that the cost type exists before calling in situations where throwing is not possible, or unwanted. </dd></dl>

</div>
</div>
<a id="a1106422ecd12416e8931a0e1f4b4fc50" name="a1106422ecd12416e8931a0e1f4b4fc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1106422ecd12416e8931a0e1f4b4fc50">&#9670;&#160;</a></span>GetCostForSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float HF::SpatialStructures::Graph::GetCostForSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01547.html">EdgeCostSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cost of traversing the edge between parent and child using set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The set of edges to get this cost in </td></tr>
    <tr><td class="paramname">parent_id</td><td>ID of the edge's parent node. </td></tr>
    <tr><td class="paramname">child_id</td><td>ID of the edge's child node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NAN if no edge exists in <code>set</code> between <code>parent_id</code> and <code>child_id</code>. If an edge does exist betwen <code>parent_id</code> and <code>child_id</code> in <code>set</code> then returns the cost</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>parent_id and child_id both belong to nodes that already exist in the graph. </dd></dl>

</div>
</div>
<a id="a8803f69bbfaebcdae72680e01a90b94b" name="a8803f69bbfaebcdae72680e01a90b94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8803f69bbfaebcdae72680e01a90b94b">&#9670;&#160;</a></span>GetCostTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; HF::SpatialStructures::Graph::GetCostTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an array of all cost names within this graph. </p>
<dl class="section return"><dt>Returns</dt><dd>A list of all cost_types that exist within this graph (excluding the default cost array). </dd></dl>

</div>
</div>
<a id="a7cd5d401dfbd61b3b075ca0ad63d959e" name="a7cd5d401dfbd61b3b075ca0ad63d959e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd5d401dfbd61b3b075ca0ad63d959e">&#9670;&#160;</a></span>GetCSRPointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01539.html">CSRPtrs</a> HF::SpatialStructures::Graph::GetCSRPointers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the size of and pointers to the 3 arrays that comprise this graph's CSR. graph if it isn't compressed already  </p>
<dl class="section return"><dt>Returns</dt><dd>Pointers and sizes of the arrays that comprise the CSR. If the CSR cannot be constructed due to factors such as an empty input array, then the <a class="el" href="a01539.html" title="A struct to hold all necessary information for a CSR.">CSRPtrs</a> contain null values for it's pointers. </dd></dl>
<p >This will automatically call Compress if it hasn't been called already.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This can be useful for reconstructing or mapping to the CSR without interacting with eigen at all. Numpy can directly make map the arrays returned by this function to it's own CSR implementation.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a pair of nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> n_parent(4.0f, 5.0f, 6.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> n_child(7.0f, 8.0f, 9.0f);</div>
<div class="line"> </div>
<div class="line">graph.addEdge(n_parent, n_child);   <span class="comment">// default score is 1.0f</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Graph will be compressed automatically be GetCSRPointers</span></div>
<div class="line">CSRPtrs returned_csr = graph.GetCSRPointers();</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="a01539.html#a4665024245e559dac8c3d620372dc47e" title="Verify the CSR referenced by this instance is valid.">CSRPtrs.AreValid()</a> for checking if the return value represents a valid CSR. </dd></dl>

<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00187">GetCSRPointers()</a>.</p>
<div id="dynsection-11" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-11-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-11-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-11-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a7cd5d401dfbd61b3b075ca0ad63d959e_icgraph.svg" width="344" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1a26ebb794b444e2214cf0b0fed5a529" name="a1a26ebb794b444e2214cf0b0fed5a529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a26ebb794b444e2214cf0b0fed5a529">&#9670;&#160;</a></span>GetEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a01535.html">EdgeSet</a> &gt; HF::SpatialStructures::Graph::GetEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get every in the given graph as IDs.  </p>
<dl class="section return"><dt>Returns</dt><dd>An array of edgesets for every node in the graph (<a class="el" href="a01551.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">Graph</a> in the form of IDs). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the graph hasn't been compressed. compressed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time Complexity</dt><dd>O(k) where k is the number of edges in the graph.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// graph must be compressed, or a exception will be thrown</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// To brief, an EdgeSet has the following layout: struct EdgeSet { int parent;</span></div>
<div class="line"><span class="comment">// std::vector&lt;IntEdge&gt; children; };</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// An IntEdge has the following layout: struct IntEdge { int child; float weight; };</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A std::vector&lt;EdgeSet&gt; is a Graph, in the form of IDs.</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::EdgeSet&gt; edge_set = graph.GetEdges();</div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00197_source.html#l00023">HF::Pathfinding::BoostGraph::BoostGraph()</a>.</p>
<div id="dynsection-12" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-12-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-12-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-12-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a1a26ebb794b444e2214cf0b0fed5a529_icgraph.svg" width="392" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad398849b00a0eac24c0682935d8c7966" name="ad398849b00a0eac24c0682935d8c7966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad398849b00a0eac24c0682935d8c7966">&#9670;&#160;</a></span>GetEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a01535.html">EdgeSet</a> &gt; HF::SpatialStructures::Graph::GetEdges </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges of a specfic cost type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost_name</td><td>The name of the cost to get edges for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An edge set for the edges of <code>cost_name</code></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a01335.html" title="Thrown when a dependency is missing such as Embree.">HF::Exceptions::NoCost</a></td><td>The cost at `cost_name` didn't exist in the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa143ac9a9e8dbf23fec49a47ca01cdb2" name="aa143ac9a9e8dbf23fec49a47ca01cdb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa143ac9a9e8dbf23fec49a47ca01cdb2">&#9670;&#160;</a></span>GetEdgesForNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a01527.html">Edge</a> &gt; HF::SpatialStructures::Graph::GetEdgesForNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the edges for the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td><a class="el" href="a02071.html" title="A point in space with an ID.">Node</a> to get the outgoing edges of </td></tr>
    <tr><td class="paramname">undirected</td><td>If this is true, then get both outgoing and incoming edges of parent_id </td></tr>
    <tr><td class="paramname">cost_type</td><td>Cost type to use for retrieved edges</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All edges from (or to if undirected is true) parent_id for the given cost type</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NoCost</td><td>if cost_type isn't eh default graph and doesn't exist in the graph's cost types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af59beedafb4af0ee99d54761e1c681fc" name="af59beedafb4af0ee99d54761e1c681fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59beedafb4af0ee99d54761e1c681fc">&#9670;&#160;</a></span>getID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::getID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the ID for node in this graph.  </p>
<dl class="section return"><dt>Returns</dt><dd>The ID assigned to this node. -1 if it was not yet added to the graph </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> other_node(55.0f, 66.1f, 15.5f, 9510);  <span class="comment">// Let&#39;s construct a Node we know is not in graph.</span></div>
<div class="line"><span class="keywordtype">bool</span> has_key = graph.hasKey(other_node);                            <span class="comment">// other_node does not exist in graph, so has_key == false;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> ID = graph.getID(other_node);                                   <span class="comment">// ID will assigned -1, because other_node is not a part of graph.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Likewise, if we pass a Node instance that indeed exists...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of</span></div>
<div class="line"><span class="comment">// std::vector&lt;Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.Nodes();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to hasKey. Any node that</span></div>
<div class="line"><span class="comment">// exists with graph can be passed to this member function to determine if the graph</span></div>
<div class="line"><span class="comment">// has the node&#39;s key, or not.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;                  <span class="comment">// we assume for this example that index 2 is valid.</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> good_node = get_nodes[index];</div>
<div class="line"> </div>
<div class="line">ID = graph.getID(good_node);    <span class="comment">// ID &gt; -1, i.e. it is a Node instance that exists within this Graph.</span></div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00217">GetNodeID()</a>.</p>
<div id="dynsection-13" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-13-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-13-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-13-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_af59beedafb4af0ee99d54761e1c681fc_icgraph.svg" width="290" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad5227cd95744b58551b9964975017a37" name="ad5227cd95744b58551b9964975017a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5227cd95744b58551b9964975017a37">&#9670;&#160;</a></span>GetIntEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a01531.html">IntEdge</a> &gt; HF::SpatialStructures::Graph::GetIntEdges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get children of a specific node as integers. </p>

</div>
</div>
<a id="aedd218785fbf6dabaa2fba2dca738618" name="aedd218785fbf6dabaa2fba2dca738618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd218785fbf6dabaa2fba2dca738618">&#9670;&#160;</a></span>GetNodeAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; HF::SpatialStructures::Graph::GetNodeAttributes </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>attribute</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the score for the given attribute of every node in the graph. Nodes that do not have a score for this attribute should return an empty string for this array.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>The attribute from which a container of scores will be obtained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A container of score, each in the form of a std::string, obtained from attribute </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00434_source.html#l00322">GetNodeAttributes()</a>.</p>
<div id="dynsection-14" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-14-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-14-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-14-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_aedd218785fbf6dabaa2fba2dca738618_icgraph.svg" width="367" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afca147a681e4b39bc471e02d0f07eb37" name="afca147a681e4b39bc471e02d0f07eb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca147a681e4b39bc471e02d0f07eb37">&#9670;&#160;</a></span>getOrAssignID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::getOrAssignID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>input_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unique ID for this x, y, z position and assign it an new one if it doesn't already exist. </p>
<p >If the node has not yet been seen by the graph, next_id will be assigned to it and incremented, then the node node will and its new id will be added to idmap. If the node has already been assigned an ID, then the ID will be returned directly from idmap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_node</td><td><a class="el" href="a02071.html" title="A point in space with an ID.">Node</a> to retrieve and potentially assign a new ID for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID of input_node.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// definition of Graph::addEdge(const Node&amp; parent, const Node&amp; child, float score)</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">        </div>
<div class="line">        <span class="comment">// Get parent/child ids</span></div>
<div class="line">        <span class="keywordtype">int</span> parent_id = <a class="code hl_function" href="a01551.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a>(parent);</div>
<div class="line">        <span class="keywordtype">int</span> child_id = <a class="code hl_function" href="a01551.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a>(child);</div>
<div class="line">    </div>
<div class="line">        <span class="comment">// If this is already compressed, update the CSR, otherwise add it to the list of triplets.</span></div>
<div class="line">        <a class="code hl_function" href="a01551.html#a17fd1ad405195ad5455c8bbad34816d3">InsertOrUpdateEdge</a>(parent_id, child_id, score, cost_type);</div>
<div class="ttc" id="aa01551_html_a17fd1ad405195ad5455c8bbad34816d3"><div class="ttname"><a href="a01551.html#a17fd1ad405195ad5455c8bbad34816d3">HF::SpatialStructures::Graph::InsertOrUpdateEdge</a></div><div class="ttdeci">void InsertOrUpdateEdge(int parent_id, int child_id, float score, const std::string &amp;cost_type)</div><div class="ttdoc">Insert an edge into the default cost array or a new cost array.</div></div>
<div class="ttc" id="aa01551_html_afca147a681e4b39bc471e02d0f07eb37"><div class="ttname"><a href="a01551.html#afca147a681e4b39bc471e02d0f07eb37">HF::SpatialStructures::Graph::getOrAssignID</a></div><div class="ttdeci">int getOrAssignID(const Node &amp;input_node)</div><div class="ttdoc">Get the unique ID for this x, y, z position and assign it an new one if it doesn't already exist.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a133b6f44ac90ed6135752e32482b70f5" name="a133b6f44ac90ed6135752e32482b70f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133b6f44ac90ed6135752e32482b70f5">&#9670;&#160;</a></span>getOrAssignID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::getOrAssignID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input_int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an ID to the graph if it doesn't exist already. </p>
<dl class="section warning"><dt>Warning</dt><dd>Adding integer edges to the graph isn't entirely supported. This WILL create gaps in the CSR, and break the order of ordered_nodes.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// definition of Graph::addEdge(int parent_id, int child_id, float score)</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"> </div>
<div class="line">        <span class="comment">// Store these Ids in the hashmap if they don&#39;t exist already.</span></div>
<div class="line">        <a class="code hl_function" href="a01551.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a>(child_id);</div>
<div class="line">        <a class="code hl_function" href="a01551.html#afca147a681e4b39bc471e02d0f07eb37">getOrAssignID</a>(parent_id);</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="a01551.html#a17fd1ad405195ad5455c8bbad34816d3">InsertOrUpdateEdge</a>(parent_id, child_id, score, cost_type);</div>
<div class="line">        </div>
</div><!-- fragment --> 
</div>
</div>
<a id="a83c1c898465d3ea1b1459e529fd10831" name="a83c1c898465d3ea1b1459e529fd10831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c1c898465d3ea1b1459e529fd10831">&#9670;&#160;</a></span>GetOrCreateCostType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01547.html">EdgeCostSet</a> &amp; HF::SpatialStructures::Graph::GetOrCreateCostType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the edge matrix, or create a new one if it doesn't exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the cost matrix to create or retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the existing cost array, or the newly created cost array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>key</code> is not the default name in the graph or an empty string. </dd></dl>

</div>
</div>
<a id="a89250c619a726fd0adbd71778d166887" name="a89250c619a726fd0adbd71778d166887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89250c619a726fd0adbd71778d166887">&#9670;&#160;</a></span>GetSubgraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00465.html#a01543">Subgraph</a> HF::SpatialStructures::Graph::GetSubgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a <a class="el" href="a00465.html#a01543" title="A Subgraph consists of a parent Node m_parent and a container of Edge m_edges such that all Edge in m...">Subgraph</a> using a <a class="el" href="a02071.html" title="A point in space with an ID.">Node</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_node</td><td>The parent node from which the <a class="el" href="a00465.html#a01543" title="A Subgraph consists of a parent Node m_parent and a container of Edge m_edges such that all Edge in m...">Subgraph</a> will be derived </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A structure that consists of parent_node and the container of <a class="el" href="a01527.html" title="A connection to a child node.">Edge</a> that consists of the <a class="el" href="a01527.html" title="A connection to a child node.">Edge</a> that extend from parent</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00254_source.html#l00283">HF::SpatialStructures::CostAlgorithms::CalculateCrossSlope()</a>, and <a class="el" href="a00254_source.html#l00162">HF::SpatialStructures::CostAlgorithms::CalculateEnergyExpenditure()</a>.</p>
<div id="dynsection-15" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-15-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-15-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-15-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a89250c619a726fd0adbd71778d166887_icgraph.svg" width="388" height="152"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9477544edee32c4bebc69ebedd96642a" name="a9477544edee32c4bebc69ebedd96642a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9477544edee32c4bebc69ebedd96642a">&#9670;&#160;</a></span>GetSubgraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00465.html#a01543">Subgraph</a> HF::SpatialStructures::Graph::GetSubgraph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a <a class="el" href="a00465.html#a01543" title="A Subgraph consists of a parent Node m_parent and a container of Edge m_edges such that all Edge in m...">Subgraph</a> using a parent node ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td>The parent node id from which the <a class="el" href="a00465.html#a01543" title="A Subgraph consists of a parent Node m_parent and a container of Edge m_edges such that all Edge in m...">Subgraph</a> will be derived </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A structure that consists of the node at parent_id and the container of <a class="el" href="a01527.html" title="A connection to a child node.">Edge</a> that consists of the <a class="el" href="a01527.html" title="A connection to a child node.">Edge</a> that extend from parent_id</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// TODO example</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac86208fa647a5a7fdbc18c0cd9d5d5a3" name="ac86208fa647a5a7fdbc18c0cd9d5d5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86208fa647a5a7fdbc18c0cd9d5d5a3">&#9670;&#160;</a></span>GetUndirectedEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a01527.html">Edge</a> &gt; HF::SpatialStructures::Graph::GetUndirectedEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of all edges to and from node N.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The <a class="el" href="a02071.html" title="A point in space with an ID.">Node</a> to get edges from and to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of edges to and from node N or an empty array if is not in the graph. </dd></dl>
<dl class="section user"><dt>Time Complexity</dt><dd><code>O(k)</code> where k is the number of edges in the graph since it needs to iterate through every edge in the graph to find the edges to this node.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>operator[] to get a list of directed edges only containing edges from N.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of</span></div>
<div class="line"><span class="comment">// std::vector&lt;HF::SpatialStructures::Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.Nodes();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to GetUndirectedEdges.</span></div>
<div class="line"><span class="comment">// Any node that exists with graph can be passed to this member function to retrieve</span></div>
<div class="line"><span class="comment">// a vector of undirected edges.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;</div>
<div class="line">std::vector&lt;HF::SpatialStructures::Edge&gt; undirected_edges = graph.GetUndirectedEdges(get_nodes[index]);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7fb8dbfe1b401c67d85e7a0f361ebd69" name="a7fb8dbfe1b401c67d85e7a0f361ebd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb8dbfe1b401c67d85e7a0f361ebd69">&#9670;&#160;</a></span>Graph::AddEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::Graph::AddEdges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="a01531.html">IntEdge</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a set of intedges to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>An ordered vector of vectors in which each outer vector holds a vector of edges for the node at the ID of that index. For example the vector at index 0 would hold a vector of intedges for the node at ID 0.a</td></tr>
    <tr><td class="paramname">cost_type</td><td>The type of cost to add these edges to. If this cost type does not yet exist, then it will be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) If adding edges to an alternate cost type, the edges must already have been added to the default graph. </dd>
<dd>
2) If adding an alternate edge to the graph, the graph must already be compressed</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>Trying to add an edge to an alternate cost type when it's not compressed </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>Trying to add an edge to an alternate cost type when it hasn't already been added to the default graph2) If adding an alternate edge to the graph, the graph must already be compressed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42d18ac87da28a676ec110d1d9c86b80" name="a42d18ac87da28a676ec110d1d9c86b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d18ac87da28a676ec110d1d9c86b80">&#9670;&#160;</a></span>HasCostArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasCostArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if we have this edge matrix already defined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Unique</td><td>key of the cost type to search for in the cost map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True there is a cost with this name, false otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Key does not belong to the default graph. </dd></dl>

</div>
</div>
<a id="ab6bfa0a8e88ef1fdf54597597b1a1291" name="ab6bfa0a8e88ef1fdf54597597b1a1291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bfa0a8e88ef1fdf54597597b1a1291">&#9670;&#160;</a></span>HasEdge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge from parent to child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of the edge to check for. </td></tr>
    <tr><td class="paramname">child</td><td>Child of the edge to check for. </td></tr>
    <tr><td class="paramname">undirected</td><td>If true, look for an edge from child to parent as well. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an edge between parentand child exists (also child and parent if undirected is true).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Gets the IDs of both nodes, then calls the integer overload.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the graph is uncompressed. <div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// last argument can be true/false for undirected/directed graph respectively</span></div>
<div class="line"><span class="keywordtype">bool</span> has_edge = graph.HasEdge(node_1, node_2, <span class="keyword">true</span>);</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af00121404a647b0d619f201cf9ebc797" name="af00121404a647b0d619f201cf9ebc797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00121404a647b0d619f201cf9ebc797">&#9670;&#160;</a></span>HasEdge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasEdge </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; float, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; float, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge from parent to child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent of the edge to check for. </td></tr>
    <tr><td class="paramname">child</td><td>Child of the edge to check for. </td></tr>
    <tr><td class="paramname">undirected</td><td>If true, look for an edge from child to parent as well. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an edge between parent and child exists (also child and parent if undirected is true).</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Converts parent and child to <a class="el" href="a02071.html" title="A point in space with an ID.">Node</a> then calls the node overload.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the matrix is uncompressed. <div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare {x, y, z} coordinates (positions)</span></div>
<div class="line"><span class="keyword">auto</span> parent_pos = node_1.getArray();        <span class="comment">// (2.0, 3.0, 4.0)</span></div>
<div class="line"><span class="keyword">auto</span> child_pos = node_2.getArray();         <span class="comment">// (11.0, 22.0, 140.0)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// last argument can be true/false for undirected/directed graph respectively</span></div>
<div class="line"><span class="keywordtype">bool</span> has_edge = graph.HasEdge(parent_pos, child_pos, <span class="keyword">true</span>);</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8932d45fe1608935afcdc20b462ec93b" name="a8932d45fe1608935afcdc20b462ec93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8932d45fe1608935afcdc20b462ec93b">&#9670;&#160;</a></span>HasEdge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undirected</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4de020064d58c4ab376a26c30be863a3" name="a4de020064d58c4ab376a26c30be863a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de020064d58c4ab376a26c30be863a3">&#9670;&#160;</a></span>hasKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::hasKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if n exists in the graph.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td><a class="el" href="a02071.html" title="A point in space with an ID.">Node</a> to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node exists, false otherwise. </dd></dl>
<p >Performs a single hash to check if n exists in the hashmap.</p>
<dl class="section user"><dt>Time Complexity</dt><dd>O(1) since it's a single hash function.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> other_node(55.0f, 66.1f, 15.5f, 9510);  <span class="comment">// Let&#39;s construct a Node we know is not in graph.</span></div>
<div class="line"><span class="keywordtype">bool</span> has_key = graph.hasKey(other_node);    <span class="comment">// other_node does not exist in graph, so has_key == false;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Likewise, if we pass a Node instance that indeed exists...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of</span></div>
<div class="line"><span class="comment">// std::vector&lt;Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.Nodes();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to hasKey. Any node that</span></div>
<div class="line"><span class="comment">// exists with graph can be passed to this member function to determine if the graph</span></div>
<div class="line"><span class="comment">// has the node&#39;s key, or not.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> good_node = get_nodes[index];</div>
<div class="line"> </div>
<div class="line">has_key = graph.hasKey(good_node);      <span class="comment">// now has_key is true</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afb7fd113e4afe1d0eb01dd23d69b5ecd" name="afb7fd113e4afe1d0eb01dd23d69b5ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7fd113e4afe1d0eb01dd23d69b5ecd">&#9670;&#160;</a></span>hasKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::hasKey </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this ID has already been assigned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Id of the node to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the ID has already been assigned to a node in the graph. False otherwise.</dd></dl>
<dl class="section user"><dt>TimeComplexity</dt><dd>Performs a search over every node in the graph: O(n). </dd></dl>

</div>
</div>
<a id="a42f23c075c3a912a5c12b8d243f15f70" name="a42f23c075c3a912a5c12b8d243f15f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f23c075c3a912a5c12b8d243f15f70">&#9670;&#160;</a></span>HasNodeAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::HasNodeAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this graph has a specific node attribute. </p>

</div>
</div>
<a id="ae4e5419a528f50749f8c98305f6b4390" name="ae4e5419a528f50749f8c98305f6b4390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e5419a528f50749f8c98305f6b4390">&#9670;&#160;</a></span>InsertEdgeIntoCostSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::InsertEdgeIntoCostSet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01547.html">EdgeCostSet</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an edge to a cost set between parent_id and child_id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td>The id of the parent node in the graph </td></tr>
    <tr><td class="paramname">child_id</td><td>the ID of the child node in the graph</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>no edge from parent_id to child_id exists in the default cost type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) An edge from parent to child already exists in the graph for the default cost type. </dd>
<dd>
2) parent_id and child_id are both IDs of nodes that already exist in the graph. </dd></dl>

</div>
</div>
<a id="a023c10dad1e62b235f80168ceb71c75a" name="a023c10dad1e62b235f80168ceb71c75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023c10dad1e62b235f80168ceb71c75a">&#9670;&#160;</a></span>InsertEdgesIntoCostSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::InsertEdgesIntoCostSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01547.html">EdgeCostSet</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a01535.html">EdgeSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>es</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert edges for a specific cost type into a cost set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost_set</td><td>Set of costs to insert edges into. </td></tr>
    <tr><td class="paramname">es</td><td>An array of edge_sets containing parent and child nodes to add to the graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All edges in es already exist in the default graph. </dd></dl>

</div>
</div>
<a id="a17fd1ad405195ad5455c8bbad34816d3" name="a17fd1ad405195ad5455c8bbad34816d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fd1ad405195ad5455c8bbad34816d3">&#9670;&#160;</a></span>InsertOrUpdateEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::InsertOrUpdateEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an edge into the default cost array or a new cost array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td>ID of the edge's parent node </td></tr>
    <tr><td class="paramname">child_id</td><td>ID of the edge's child node </td></tr>
    <tr><td class="paramname">score</td><td>Cost of traversing from parent to child </td></tr>
    <tr><td class="paramname">cost_type</td><td>The type of cost to add this edge to</td></tr>
  </table>
  </dd>
</dl>
<p>If the graph isn't compressed, calls <a class="el" href="a01551.html#a1c600a342694552e17cf8705d90163ef" title="Add a new edge to the triplets list.">TripletsAddOrUpdateEdge()</a>. If the graph is compressed calls <a class="el" href="a01551.html#ab8814e293547af636e63e45e400574de" title="Add a new edge cost to the CSR or update if if a cost already exists.">CSRAddOrUpdateEdge()</a>. If the cost at cost_type doesn't exist, then it will be created.</p>
<dl class="section pre"><dt>Precondition</dt><dd>1) parent_id and child_id already exist in the graph. </dd>
<dd>
2) If not using the default cost_type the must already be compressed. </dd>
<dd>
3) Any edges being added to alternate cost types already exist in the default graph.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If trying to add an edge to an alternate cost type when the graph hasn't been compressed. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>If trying to add an edge between nodes that doesn't exist already in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c6ed0440c3e83f18dc3c0393a4db63f" name="a1c6ed0440c3e83f18dc3c0393a4db63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6ed0440c3e83f18dc3c0393a4db63f">&#9670;&#160;</a></span>IsDefaultName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::IsDefaultName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this name belongs to the default graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to test against the default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this name belongs to the default CSR. False otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default name is either the name the graph was constructed with ("Distance" if none) or an empty string that returns true when calling string.empty(). </dd></dl>

</div>
</div>
<a id="a40581bf5c7751041e85e1763697cdb70" name="a40581bf5c7751041e85e1763697cdb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40581bf5c7751041e85e1763697cdb70">&#9670;&#160;</a></span>MapCostMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00465.html#aaf74b9079d1b97124b8d1e4dae2cc13c">TempMatrix</a> HF::SpatialStructures::Graph::MapCostMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cost_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a temp matrix for the specific cost type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost_type</td><td>The type of cost to generate the temp matrix for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly constructed TempMatrix with the outer and inner indices of the default edge_matrix but the values of <code>cost_type</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) cost_type must be a valid cost type that already exists in the graph </dd>
<dd>
2) cost_type must not be the default cost type. </dd></dl>

</div>
</div>
<a id="a5d1505ad796c9f222c923a1a22980bb2" name="a5d1505ad796c9f222c923a1a22980bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1505ad796c9f222c923a1a22980bb2">&#9670;&#160;</a></span>MaxID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::MaxID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the maximum ID of any node in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum ID of any node ing the graph.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This shouldn't be needed often, as unless this graph has integer edges, nodes will always be stored in order. </dd></dl>

<p class="reference">Referenced by <a class="el" href="a00197_source.html#l00023">HF::Pathfinding::BoostGraph::BoostGraph()</a>.</p>
<div id="dynsection-16" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-16-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-16-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-16-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a5d1505ad796c9f222c923a1a22980bb2_icgraph.svg" width="392" height="54"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a794c342603cefb342fdc698ba539b25f" name="a794c342603cefb342fdc698ba539b25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794c342603cefb342fdc698ba539b25f">&#9670;&#160;</a></span>NodeFromID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02071.html">Node</a> HF::SpatialStructures::Graph::NodeFromID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the node that corresponds to id.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the node to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node corresponding to id, by value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>id didn't belong to any node in the graph. <div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let&#39;s retrieve node_1.</span></div>
<div class="line"><span class="keywordtype">int</span> desired_node_id = 2;</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_from_id = graph.NodeFromID(desired_node_id);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note that NodeFromID ceases to work if the id argument provided does not exist as</span></div>
<div class="line"><span class="comment">// an ID among the nodes within graph</span></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa70347b8a33b57c6f0a72d6eca4248d7" name="aa70347b8a33b57c6f0a72d6eca4248d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70347b8a33b57c6f0a72d6eca4248d7">&#9670;&#160;</a></span>Nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="a02071.html">Node</a> &gt; HF::SpatialStructures::Graph::Nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of nodes from the graph sorted by ID.  </p>
<dl class="section return"><dt>Returns</dt><dd>A sorted vector of nodes. </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nodes() returns a copy of the ordered_nodes field</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes_from_graph = graph.Nodes();</div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00254_source.html#l00283">HF::SpatialStructures::CostAlgorithms::CalculateCrossSlope()</a>, <a class="el" href="a00254_source.html#l00162">HF::SpatialStructures::CostAlgorithms::CalculateEnergyExpenditure()</a>, <a class="el" href="a00404_source.html#l00022">GenerateGraph()</a>, <a class="el" href="a00404_source.html#l00062">GenerateGraphObstacles()</a>, and <a class="el" href="a00434_source.html#l00032">GetAllNodesFromGraph()</a>.</p>
<div id="dynsection-17" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-17-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-17-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-17-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_aa70347b8a33b57c6f0a72d6eca4248d7_icgraph.svg" width="386" height="304"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aeddbbec01c6354b7076f47f71fc1a220" name="aeddbbec01c6354b7076f47f71fc1a220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddbbec01c6354b7076f47f71fc1a220">&#9670;&#160;</a></span>NodesAsFloat3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; float, 3 &gt; &gt; HF::SpatialStructures::Graph::NodesAsFloat3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of nodes as float arrays.  </p>
<dl class="section return"><dt>Returns</dt><dd>An array of float arrays containing the position of every node in the graph in order. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>May be useful for to functions that take arrays instead of nodes.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A container of std::array&lt;float, 3&gt; is constructed and populated within</span></div>
<div class="line"><span class="comment">// NodesAsFloat3, and returned. Each array of 3 floats represents a Node&#39;s position</span></div>
<div class="line"><span class="comment">// within the Cartesian coordinate system. { x, y, z }</span></div>
<div class="line">std::vector&lt;std::array&lt;float, 3&gt;&gt; nodes_as_floats = graph.NodesAsFloat3();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The two loops below will yield the same output</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> n : graph.Nodes()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; n.x &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; n.y &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; n.z &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> a : nodes_as_floats) {</div>
<div class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7c2ea4fda7d310b500456ff14527bab9" name="a7c2ea4fda7d310b500456ff14527bab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2ea4fda7d310b500456ff14527bab9">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="a01527.html">Edge</a> &gt; HF::SpatialStructures::Graph::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02071.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="a00452.html#_todo000025">Todo:</a></b></dt><dd>Should this just return an empty list instead of throwing? </dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the nodes from the graph, or use the original instance of</span></div>
<div class="line"><span class="comment">// std::vector&lt;Node&gt; passed to Graph upon instantiation</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; get_nodes = graph.Nodes();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nodes[index] yields an instance of Node that we can pass to GetUndirectedEdges.</span></div>
<div class="line"><span class="comment">// Any node that exists with graph can be passed to this member function to retrieve</span></div>
<div class="line"><span class="comment">// a vector of edges.</span></div>
<div class="line"><span class="keywordtype">int</span> index = 2;</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node = get_nodes[index];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note that if node does not exist within graph, that an exception will be thrown.</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Edge&gt; undirected_edges = graph[node];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// See a (node)-&gt;(child_node_0, child_node_1, ... child_node_n)</span></div>
<div class="line">std::cout &lt;&lt; node.<a class="code hl_function" href="a02071.html#a51c4642674d54d02b8600f7ffeb45670">getArray</a>() &lt;&lt; <span class="stringliteral">&quot;-&gt;&quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> e : undirected_edges) {</div>
<div class="line">    std::cout &lt;&lt; e.child.getArray() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="ttc" id="aa02071_html_a51c4642674d54d02b8600f7ffeb45670"><div class="ttname"><a href="a02071.html#a51c4642674d54d02b8600f7ffeb45670">HF::SpatialStructures::Node::getArray</a></div><div class="ttdeci">std::array&lt; float, 3 &gt; getArray() const</div><div class="ttdoc">Returns the x,y,z of this node as an array of 3 floats.</div><div class="ttdef"><b>Definition:</b> <a href="a03554_source.html#l00141">node.cpp:141</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a174c4c57d4849cd014ec3b1e9cc474de" name="a174c4c57d4849cd014ec3b1e9cc474de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174c4c57d4849cd014ec3b1e9cc474de">&#9670;&#160;</a></span>ResizeIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::ResizeIfNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the CSR to fit all the nodes in ordered_nodes if needed. </p>
<p >If the CSR can already fit all of the ndoes in ordered_nodes then this won't do anything.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The CSR will be large enough to fit all of the nodes in ordered_nodes. </dd></dl>

</div>
</div>
<a id="a2710af2a75976862d7a235793567d2f3" name="a2710af2a75976862d7a235793567d2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2710af2a75976862d7a235793567d2f3">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine how many nodes are in the graph.  </p>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes in the graph. </dd></dl>
<p >Size is directly returned from <code>id_to_nodes.size()</code>. </p><div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;graph.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the nodes</span></div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_0(1.0f, 1.0f, 2.0f, 4);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_1(2.0f, 3.0f, 4.0f, 5);</div>
<div class="line"><a class="code hl_struct" href="a02071.html">HF::SpatialStructures::Node</a> node_2(11.0f, 22.0f, 140.0f, 6);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a container (vector) of nodes</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; nodes = { node_0, node_1, node_2 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create matrices for edges and distances, edges.size() == distances().size()</span></div>
<div class="line">std::vector&lt;std::vector&lt;int&gt;&gt; edges = { { 1, 2 }, { 2 }, { 1 } };</div>
<div class="line">std::vector&lt;std::vector&lt;float&gt;&gt; distances = { { 1.0f, 2.5f }, { 54.0f }, { 39.0f } };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can create a Graph - note that nodes, edges, and distances are passed by reference</span></div>
<div class="line"><span class="comment">// Note: graph is compressed upon instantiation</span></div>
<div class="line"><a class="code hl_class" href="a01551.html">HF::SpatialStructures::Graph</a> graph(edges, distances, nodes);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> id_count = graph.size();          <span class="comment">// We retrieve the size of the node id count within graph (3)</span></div>
</div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="a00197_source.html#l00023">HF::Pathfinding::BoostGraph::BoostGraph()</a>, <a class="el" href="a00026_source.html#l00128">HF::VisibilityGraph::AllToAll()</a>, <a class="el" href="a00026_source.html#l00252">HF::VisibilityGraph::AllToAllUndirected()</a>, <a class="el" href="a00434_source.html#l00400">GetSizeOfGraph()</a>, and <a class="el" href="a00026_source.html#l00189">HF::VisibilityGraph::GroupToGroup()</a>.</p>
<div id="dynsection-18" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-18-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-18-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-18-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01551_a2710af2a75976862d7a235793567d2f3_icgraph.svg" width="619" height="304"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1c600a342694552e17cf8705d90163ef" name="a1c600a342694552e17cf8705d90163ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c600a342694552e17cf8705d90163ef">&#9670;&#160;</a></span>TripletsAddOrUpdateEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HF::SpatialStructures::Graph::TripletsAddOrUpdateEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>child_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new edge to the triplets list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_id</td><td>Id of the parent node. </td></tr>
    <tr><td class="paramname">child_id</td><td>Id of the child node. </td></tr>
    <tr><td class="paramname">cost</td><td>Cost of traversing from parent to child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>parent_id and child_id point to valid nodes in the graph. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a73aed491dde212682fe65e248114371b" name="a73aed491dde212682fe65e248114371b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73aed491dde212682fe65e248114371b">&#9670;&#160;</a></span>active_cost_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string HF::SpatialStructures::Graph::active_cost_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The active edge matrix to use for the graph. </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00501">501</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="aba19080a765d7a09b0acbf8ffdcd1277" name="aba19080a765d7a09b0acbf8ffdcd1277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba19080a765d7a09b0acbf8ffdcd1277">&#9670;&#160;</a></span>default_cost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string HF::SpatialStructures::Graph::default_cost = &quot;Distance&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00504">504</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a4db3f8505fa2e7a4a54060fede1770f6" name="a4db3f8505fa2e7a4a54060fede1770f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db3f8505fa2e7a4a54060fede1770f6">&#9670;&#160;</a></span>edge_cost_maps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, <a class="el" href="a01547.html">EdgeCostSet</a>&gt; HF::SpatialStructures::Graph::edge_cost_maps</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt; The default cost type of the graph. </p>
<p >Hashmap containing evey alternate cost type </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00505">505</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a0be5d62e01eabe7e1581d238cfb35ace" name="a0be5d62e01eabe7e1581d238cfb35ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be5d62e01eabe7e1581d238cfb35ace">&#9670;&#160;</a></span>edge_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00465.html#a40b235356dfcdd3f2e1adc0f3c342007">EdgeMatrix</a> HF::SpatialStructures::Graph::edge_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The underlying CSR containing edge information. </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00502">502</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="aa0415ae8030d4c524f91538737155413" name="aa0415ae8030d4c524f91538737155413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0415ae8030d4c524f91538737155413">&#9670;&#160;</a></span>has_cost_arrays</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::has_cost_arrays = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that the graph has cost arrays. </p>
<p >If this is true, and the graph compresses again, then all cost arrays will be wrecked. An exception should be thrown in the case this happens, because this is misuse. </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00513">513</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a4da5e288f03773d18053c82731369b2a" name="a4da5e288f03773d18053c82731369b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da5e288f03773d18053c82731369b2a">&#9670;&#160;</a></span>idmap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">robin_hood::unordered_map&lt;<a class="el" href="a02071.html">Node</a>, int&gt; HF::SpatialStructures::Graph::idmap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a list of X,Y,Z positions to positions in ordered_nodes. </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00494">494</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a1cbd600663187d7cf985e9b6e7cea73f" name="a1cbd600663187d7cf985e9b6e7cea73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbd600663187d7cf985e9b6e7cea73f">&#9670;&#160;</a></span>needs_compression</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::needs_compression = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, the CSR is inaccurate and requires compression. </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00497">497</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="aaab13304c641df6fdcd3662d5c54dc78" name="aaab13304c641df6fdcd3662d5c54dc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab13304c641df6fdcd3662d5c54dc78">&#9670;&#160;</a></span>next_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HF::SpatialStructures::Graph::next_id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The id for the next unique node. </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00490">490</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="aeec76d5e193267be65a42eb1794a3abb" name="aeec76d5e193267be65a42eb1794a3abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec76d5e193267be65a42eb1794a3abb">&#9670;&#160;</a></span>node_attr_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">robin_hood::unordered_map&lt;std::string, <a class="el" href="a01551.html#acfe4780ebfdd7f66b9fa77a6f0301d52">NodeAttributeValueMap</a>&gt; HF::SpatialStructures::Graph::node_attr_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="a02071.html" title="A point in space with an ID.">Node</a> attribute type : Map of node id to node attribute. </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00499">499</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a4330f0c85299f975495124514354b271" name="a4330f0c85299f975495124514354b271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4330f0c85299f975495124514354b271">&#9670;&#160;</a></span>nodes_out_of_order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::SpatialStructures::Graph::nodes_out_of_order = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not the graph is using integer nodes. </p>
<p >This causes the graph to spend more time finding the maximum node ID, since it's not gauranteed edges will be added in order. </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00522">522</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="ad59ab7164b64e3d78b7032b28c2c6663" name="ad59ab7164b64e3d78b7032b28c2c6663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59ab7164b64e3d78b7032b28c2c6663">&#9670;&#160;</a></span>ordered_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a02071.html">Node</a>&gt; HF::SpatialStructures::Graph::ordered_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of nodes contained by the graph. </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00491">491</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a1cf07c256da74c2a03f81b4977364e85" name="a1cf07c256da74c2a03f81b4977364e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf07c256da74c2a03f81b4977364e85">&#9670;&#160;</a></span>triplets</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Eigen::Triplet&lt;float&gt; &gt; HF::SpatialStructures::Graph::triplets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Edges to be converted to a CSR when <a class="el" href="a01551.html#a41cece77d0eee98df39ecc6d3a366ec8" title="Compress the graph to a CSR and enable the usage of several functions.">Graph::Compress()</a> is called. </p>

<p class="definition">Definition at line <a class="el" href="a00269_source.html#l00496">496</a> of file <a class="el" href="a00269_source.html">graph.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Cpp/spatialstructures/src/<a class="el" href="a00269_source.html">graph.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00462.html">HF</a></li><li class="navelem"><a class="el" href="a00465.html">SpatialStructures</a></li><li class="navelem"><a class="el" href="a01551.html">Graph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
