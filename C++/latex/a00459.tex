\hypertarget{a00459}{}\doxysection{View\+Analysis}
\label{a00459}\index{ViewAnalysis@{ViewAnalysis}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
vector$<$ std\+::array$<$ float, 3 $>$ $>$ \mbox{\hyperlink{a00459_ga6ca336e3887ef82d17b0713c2bf862df}{HF\+::\+View\+Analysis\+::\+Fibbonacci\+Distribute\+Points}} (int num\+\_\+points, float upwards\+\_\+fov=50.\+0f, float downward\+\_\+fov=70.\+0f)
\begin{DoxyCompactList}\small\item\em Evenly distribute a set of points around a sphere centered at the origin.  \end{DoxyCompactList}\item 
{\footnotesize template$<$typename RES , typename RT , typename N $>$ }\\std\+::vector$<$ RES $>$ \mbox{\hyperlink{a00459_gaecaa04882696ac6d73173227bd28e91b}{HF\+::\+View\+Analysis\+::\+Spherical\+View\+Analysis}} (RT \&ray\+\_\+tracer, const std\+::vector$<$ N $>$ \&Nodes, int num\+\_\+rays, float upward\+\_\+limit=50.\+0f, float downward\+\_\+limit=70.\+0f, float height=1.\+7f)
\begin{DoxyCompactList}\small\item\em Conduct view analysis with any Raytracer in parallel.  \end{DoxyCompactList}\item 
{\footnotesize template$<$typename RT , typename N $>$ }\\std\+::vector$<$ float $>$ \mbox{\hyperlink{a00459_ga78f77d24531d0fa55c9b60d7ec1bf32a}{HF\+::\+View\+Analysis\+::\+Spherical\+Rayshoot\+With\+Any\+RTFor\+Distance}} (RT \&ray\+\_\+tracer, const std\+::vector$<$ N $>$ \&Nodes, int num\+\_\+rays, float upward\+\_\+limit=50.\+0f, float downward\+\_\+limit=70.\+0f, float height=1.\+7f, const \mbox{\hyperlink{a00466_a1fcaa17d2a8df8896a3b0447973bd07b}{AGGREGATE\+\_\+\+TYPE}} aggregation=\mbox{\hyperlink{a00466_a1fcaa17d2a8df8896a3b0447973bd07ba6970bdc2201030b9c03fbdcf3973858a}{AGGREGATE\+\_\+\+TYPE\+::\+SUM}})
\begin{DoxyCompactList}\small\item\em Conduct view analysis and recieve a summarized set of results for each node.  \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} \mbox{\hyperlink{a00459_gab6b8e3eab649b42ac014fb7d02d54892}{Sphereical\+View\+Analysis\+Aggregate}} (\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$ERT, \mbox{\hyperlink{a02071}{HF\+::\+Spatial\+Structures\+::\+Node}} $\ast$node\+\_\+ptr, int node\+\_\+size, int max\+\_\+rays, float upward\+\_\+fov, float downward\+\_\+fov, float height, \mbox{\hyperlink{a00443_a8a1aa9474094ff70818051c921c0537f}{AGGREGATE\+\_\+\+TYPE}} AT, std\+::vector$<$ float $>$ $\ast$$\ast$out\+\_\+scores, float $\ast$$\ast$out\+\_\+scores\+\_\+ptr, int $\ast$out\+\_\+scores\+\_\+size)
\begin{DoxyCompactList}\small\item\em Conduct view analysis, then aggregate the results. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} \mbox{\hyperlink{a00459_gaa4c5714c1e557ef83a03d447eb30c6d0}{Sphereical\+View\+Analysis\+Aggregate\+Flat}} (\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$ERT, const float $\ast$node\+\_\+ptr, int node\+\_\+size, int max\+\_\+rays, float upward\+\_\+fov, float downward\+\_\+fov, float height, \mbox{\hyperlink{a00443_a8a1aa9474094ff70818051c921c0537f}{AGGREGATE\+\_\+\+TYPE}} AT, std\+::vector$<$ float $>$ $\ast$$\ast$out\+\_\+scores, float $\ast$$\ast$out\+\_\+scores\+\_\+ptr, int $\ast$out\+\_\+scores\+\_\+size)
\begin{DoxyCompactList}\small\item\em Conduct view analysis, and aggregate the results. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} \mbox{\hyperlink{a00459_ga94d3ddc3981020e2852fc77e51266185}{Spherical\+View\+Analysis\+No\+Aggregate}} (\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$ERT, const \mbox{\hyperlink{a02071}{HF\+::\+Spatial\+Structures\+::\+Node}} $\ast$node\+\_\+ptr, int node\+\_\+size, int $\ast$max\+\_\+rays, float upward\+\_\+fov, float downward\+\_\+fov, float height, std\+::vector$<$ \mbox{\hyperlink{a02087}{Ray\+Result}} $>$ $\ast$$\ast$out\+\_\+results, \mbox{\hyperlink{a02087}{Ray\+Result}} $\ast$$\ast$out\+\_\+results\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Perform view analysis, then get the distance and meshid for each individual ray casted. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} \mbox{\hyperlink{a00459_ga348af4492f3e4e7ffab6da3e86de3924}{Spherical\+View\+Analysis\+No\+Aggregate\+Flat}} (\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$ERT, const float $\ast$node\+\_\+ptr, int node\+\_\+size, int $\ast$max\+\_\+rays, float upward\+\_\+fov, float downward\+\_\+fov, float height, std\+::vector$<$ \mbox{\hyperlink{a02087}{Ray\+Result}} $>$ $\ast$$\ast$out\+\_\+results, \mbox{\hyperlink{a02087}{Ray\+Result}} $\ast$$\ast$out\+\_\+results\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Perform view analysis, and get the distance and meshid for each individual ray casted. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} \mbox{\hyperlink{a00459_gaf572b7bec28d55bf2c72719742703dff}{Spherical\+Distribute}} (int $\ast$num\+\_\+rays, std\+::vector$<$ float $>$ $\ast$$\ast$out\+\_\+direction\+\_\+vector, float $\ast$$\ast$out\+\_\+direction\+\_\+data, float upward\+\_\+fov, float downward\+\_\+fov)
\begin{DoxyCompactList}\small\item\em Equally distribute points around a unit sphere. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Analyze the view from points in the environment. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{a00459_ga6ca336e3887ef82d17b0713c2bf862df}\label{a00459_ga6ca336e3887ef82d17b0713c2bf862df}} 
\index{ViewAnalysis@{ViewAnalysis}!FibbonacciDistributePoints@{FibbonacciDistributePoints}}
\index{FibbonacciDistributePoints@{FibbonacciDistributePoints}!ViewAnalysis@{ViewAnalysis}}
\doxysubsubsection{\texorpdfstring{FibbonacciDistributePoints()}{FibbonacciDistributePoints()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::array$<$ float, 3 $>$ $>$ HF\+::\+View\+Analysis\+::\+Fibbonacci\+Distribute\+Points (\begin{DoxyParamCaption}\item[{int}]{num\+\_\+points,  }\item[{float}]{upwards\+\_\+fov = {\ttfamily 50.0f},  }\item[{float}]{downward\+\_\+fov = {\ttfamily 70.0f} }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00020}{Cpp/analysismethods/src/view\+\_\+analysis.\+cpp}}$>$}



Evenly distribute a set of points around a sphere centered at the origin.  


\begin{DoxyParams}{Parameters}
{\em num\+\_\+points} & Maximum number of points to distribute. \\
\hline
{\em upward\+\_\+limit} & Maximum angle in degrees to cast rays above the viewpoint. \\
\hline
{\em downward\+\_\+limit} & Maximum angle in degrees to cast rays below the viewpoint. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector of arrays containing the x, y, and z coordinates of each point on the sphere.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The number of points returned by this function will not exactly equal the amount of points specified by num\+\_\+points depending on the values of upwards\+\_\+fov and downward fov. More information is available below.
\end{DoxyNote}
\begin{DoxyParagraph}{How FOV is implemented}
Every point is equally distributed on a sphere using a formula based on this stack overflow answer\+: \href{https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere}{\texttt{ https\+://stackoverflow.\+com/questions/9600801/evenly-\/distributing-\/n-\/points-\/on-\/a-\/sphere}}. This formula cannot easily be mapped to a specific vertical fov or cone, so instead this function will remove points that don\textquotesingle{}t meet the constraints. Discarding points causes the number of points generated to be less than the num\+\_\+rays argument, so the percentage of points discarded is calculated and a second run is performed with an adjusted num\+\_\+rays value to get as close as possible to the value specified in the argument. This approach will not result in an exact match to the num\+\_\+rays argument, and will run \mbox{\hyperlink{a00466_a5b45790c767b670bc00bf3fd2335159a}{Fibbonacci\+Dist}} twice.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Example}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Requires \#include "{}view\_analysis.h"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// For brevity}}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{a00459_ga6ca336e3887ef82d17b0713c2bf862df}{HF::ViewAnalysis::FibbonacciDistributePoints}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Prepare maximum number of points to distribute}}
\DoxyCodeLine{\textcolor{keywordtype}{int} size = 8;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Generate points without any limitations on fov}}
\DoxyCodeLine{\textcolor{keyword}{auto} points = \mbox{\hyperlink{a00459_ga6ca336e3887ef82d17b0713c2bf862df}{FibbonacciDistributePoints}}(size, 90.0f, 90.0f);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Print number of points}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"{}Number of Points:"{}} << points.size() << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Iterate through results and print every point.}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < size; i++) \{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto}\& point =  points[i];}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}("{}} << point[0] << \textcolor{stringliteral}{"{}, "{}} << point[1] << \textcolor{stringliteral}{"{}, "{}} << point[2] << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (i != size -\/ 1) std::cout << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{\}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"{}]"{}} << std::endl;}

\end{DoxyCode}

\end{DoxyParagraph}
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Number of Points\+:8}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} \mbox{[}(-\/0, -\/1, 0), (-\/0.\+304862, -\/0.\+75, -\/0.\+586992), (0.\+813476, -\/0.\+5, 0.\+29708), (-\/0.\+894994, -\/0.\+25, 0.\+369441),} {\ttfamily (0.\+423846, 0, -\/0.\+905734), (0.\+289781, 0.\+25, 0.\+923865), (-\/0.\+749296, 0.\+5, -\/0.\+43423), (0.\+64601, 0.\+75, -\/0.\+142025)\mbox{]}} 

Definition at line \mbox{\hyperlink{a00020_source_l00121}{121}} of file \mbox{\hyperlink{a00020_source}{view\+\_\+analysis.\+cpp}}.



References \mbox{\hyperlink{a00020_source_l00084}{HF\+::\+View\+Analysis\+::\+Fibbonacci\+Dist()}}.



Referenced by \mbox{\hyperlink{a00440_source_l00126}{Spherical\+Distribute()}}, \mbox{\hyperlink{a00023_source_l00484}{HF\+::\+View\+Analysis\+::\+Spherical\+Rayshoot\+With\+Any\+RTFor\+Distance()}}, and \mbox{\hyperlink{a00023_source_l00335}{HF\+::\+View\+Analysis\+::\+Spherical\+View\+Analysis()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00459_ga6ca336e3887ef82d17b0713c2bf862df_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00459_ga6ca336e3887ef82d17b0713c2bf862df_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00459_gab6b8e3eab649b42ac014fb7d02d54892}\label{a00459_gab6b8e3eab649b42ac014fb7d02d54892}} 
\index{ViewAnalysis@{ViewAnalysis}!SphereicalViewAnalysisAggregate@{SphereicalViewAnalysisAggregate}}
\index{SphereicalViewAnalysisAggregate@{SphereicalViewAnalysisAggregate}!ViewAnalysis@{ViewAnalysis}}
\doxysubsubsection{\texorpdfstring{SphereicalViewAnalysisAggregate()}{SphereicalViewAnalysisAggregate()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} Sphereical\+View\+Analysis\+Aggregate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$}]{ERT,  }\item[{\mbox{\hyperlink{a02071}{HF\+::\+Spatial\+Structures\+::\+Node}} $\ast$}]{node\+\_\+ptr,  }\item[{int}]{node\+\_\+size,  }\item[{int}]{max\+\_\+rays,  }\item[{float}]{upward\+\_\+fov,  }\item[{float}]{downward\+\_\+fov,  }\item[{float}]{height,  }\item[{\mbox{\hyperlink{a00443_a8a1aa9474094ff70818051c921c0537f}{AGGREGATE\+\_\+\+TYPE}}}]{AT,  }\item[{std\+::vector$<$ float $>$ $\ast$$\ast$}]{out\+\_\+scores,  }\item[{float $\ast$$\ast$}]{out\+\_\+scores\+\_\+ptr,  }\item[{int $\ast$}]{out\+\_\+scores\+\_\+size }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00443}{Cinterface/view\+\_\+analysis\+\_\+\+C.\+h}}$>$}



Conduct view analysis, then aggregate the results. 


\begin{DoxyParams}{Parameters}
{\em ERT} & Raytracer containing the geometry to use for ray intersections. \\
\hline
{\em node\+\_\+ptr} & Observer points for the view analysis. \\
\hline
{\em node\+\_\+size} & Number of nodes in the array pointed to by node\+\_\+ptr.\\
\hline
{\em max\+\_\+rays} & Number of rays to cast for each node in node\+\_\+ptr. Note that this may cast fewer rays than max\+\_\+rays, depending on FOV restrictions.\\
\hline
{\em upward\+\_\+fov} & Maximum degrees upward from the viewer\textquotesingle{}s eye level to consider. \\
\hline
{\em downward\+\_\+fov} & Maximum degrees downward from the viewer\textquotesingle{}s eye level to consider. \\
\hline
{\em height} & Height to offset nodes from the ground (+Z direction). \\
\hline
{\em AT} & Type of aggregation method to use. \\
\hline
{\em out\+\_\+scores} & Output parameter for node scores. \\
\hline
{\em out\+\_\+scores\+\_\+ptr} & Pointer to the data of out\+\_\+scores. \\
\hline
{\em out\+\_\+scores\+\_\+size} & Size of output\+\_\+scores\+\_\+ptr.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
HF\+::\+Status\+::\+OK on completion.
\end{DoxyReturn}
\begin{DoxyParagraph}{Caller\textquotesingle{}s Responsibility}
The caller must call \mbox{\hyperlink{a00410_af77723a4383b278169e80cf0e361ec44}{Destroy\+Float\+Vector}} with out\+\_\+scores to free the memory allocated by this function.
\end{DoxyParagraph}
\begin{DoxyPrecond}{Precondition}
1) ERT points to a valid raytracer created by Create\+Raytracer 

2) node\+\_\+ptr contains a valid array of nodes with length equal to node\+\_\+size 

3) out\+\_\+scores, out\+\_\+scores\+\_\+ptr, and out\+\_\+score\+\_\+size are not null
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
1) out\+\_\+scores contains a pointer to score for every node in nodes in order 

2) out\+\_\+scores\+\_\+ptr cpoints to a valid array of scores 

3) out\+\_\+scores\+\_\+size is updated to the length of the data held by out\+\_\+scores\+\_\+ptr
\end{DoxyPostcond}
\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000030}{Todo}}]Is there any situation where out\+\_\+scores\+\_\+size is smaller than node\+\_\+size?\end{DoxyRefDesc}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00455_mesh_setup}{Mesh setup}} (how to create a mesh), \mbox{\hyperlink{a00455_mesh_teardown}{Mesh teardown}} (how to destroy a mesh) 

\mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}} (how to create a BVH), \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} (how to destroy a BVH)

\mbox{\hyperlink{}{Spherical\+View\+Analysis}} for an algorithm that returns the results of every ray casted instead of aggregating the results.

\mbox{\hyperlink{}{Spherical\+View\+Analysis\+Aggregate\+Flat}} for a function that works on a flat array of floats instead of an array of nodes.
\end{DoxySeeAlso}
Begin by {\bfseries{loading an .obj file}} (\mbox{\hyperlink{a00455_mesh_setup}{Mesh setup}}).~\newline
 Then, {\bfseries{create a BVH}} (\mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}}) using the {\bfseries{mesh}}.~\newline


\begin{DoxyParagraph}{Example Code}

\end{DoxyParagraph}
Set up the parameters for the view analysis. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Preparing the parameters for SphereicalViewAnalysisAggregate}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Define point to start ray}}
\DoxyCodeLine{        \textcolor{comment}{// These are Cartesian coordinates.}}
\DoxyCodeLine{        std::array<Node, 3> p1\{ Node(0.0f, 0.0f, 2.0f) \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Define direction to cast ray}}
\DoxyCodeLine{        \textcolor{comment}{// These are vector components, not Cartesian coordinates.}}
\DoxyCodeLine{        std::array<float, 3> dir \{ 0.0f, 0.0f, -\/1.0f \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// This is a container of nodes to be analyzed.}}
\DoxyCodeLine{        \textcolor{comment}{// SphereicalViewAnalysisAggregate accepts a (Node *) parameter,}}
\DoxyCodeLine{        \textcolor{comment}{// so a raw stack-\/allocated array will suffice.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// This may also be a pointer to a heap-\/allocated buffer}}
\DoxyCodeLine{        \textcolor{comment}{// (which is owned by a vector<Node>, accessed via the vector<Node>::data() method).}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// ...or, it can be a pointer to memory allocated by the caller via operator new[node\_count]}}
\DoxyCodeLine{        \textcolor{comment}{// (if this route is taken, be sure to release the memory with operator delete[] after use)}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{int} node\_count = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(p1.size()); \textcolor{comment}{// should be the element count in nodes}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} ray\_count = 1000;               \textcolor{comment}{// will be mutated by SphereicalViewAnalysisAggregate}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} height = 1.7f;          \textcolor{comment}{// height to offset nodes from the ground, in meters}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} upward\_fov = 50.0f;     \textcolor{comment}{// default parameter is 50.0f in Python code}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} downward\_fov = 70.0f;   \textcolor{comment}{// default parameter is 70.0f in Python code}}

\end{DoxyCodeInclude}


Now you must prepare a pointer to a std\+::vector$<$float$>$, where the {\bfseries{aggregation results}} will be stored.~\newline
 You must also select the aggregate type. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Declare a pointer to vector<float>, named aggregate\_results.}}
\DoxyCodeLine{        \textcolor{comment}{// This pointer will point to memory on the free store,}}
\DoxyCodeLine{        \textcolor{comment}{// allocated within SphereicalViewAnalysisAggregate.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// aggregate\_results\_data will point to the underlying buffer within *aggregate\_results,}}
\DoxyCodeLine{        \textcolor{comment}{// which will be assigned inside SphereicalViewAnalysisAggregate.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Note that we must call operator delete on aggregate\_results when we are finished with it.}}
\DoxyCodeLine{        std::vector<float>* aggregate\_results = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{        \textcolor{keywordtype}{float}* aggregate\_results\_data = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Will be equal to aggregate\_results-\/>size();}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} aggregate\_results\_size = -\/1;}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Select the aggregate type.}}
\DoxyCodeLine{        \textcolor{comment}{// This determines how to aggregate the edges within the results of the view analysis.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// AGGREGATE\_TYPE::AVERAGE means that the edges will be aggregated}}
\DoxyCodeLine{        \textcolor{comment}{// by the maximum distance from the origin point to its hit points.}}
\DoxyCodeLine{        \mbox{\hyperlink{a00443_a8a1aa9474094ff70818051c921c0537f}{AGGREGATE\_TYPE}} agg\_type = \mbox{\hyperlink{a00443_a8a1aa9474094ff70818051c921c0537fa16de38737a9f8366e9b2042b4e9b6290}{AGGREGATE\_TYPE::AVERAGE}};}

\end{DoxyCodeInclude}


Now we are ready to call \mbox{\hyperlink{a00459_gab6b8e3eab649b42ac014fb7d02d54892}{Sphereical\+View\+Analysis\+Aggregate}} . 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00459_gab6b8e3eab649b42ac014fb7d02d54892}{SphereicalViewAnalysisAggregate}}(bvh,}
\DoxyCodeLine{            p1.data(), node\_count, ray\_count,}
\DoxyCodeLine{            upward\_fov, downward\_fov, height,}
\DoxyCodeLine{            agg\_type,}
\DoxyCodeLine{            \&aggregate\_results, \&aggregate\_results\_data, \&aggregate\_results\_size);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at SphereicalViewAnalysisAggregate, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


We can output the contents of the {\bfseries{aggregate results vector}} to {\bfseries{stdout}} . 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Print aggregate results vector (vector<float>)}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{        \textcolor{keywordtype}{int} i = 0;}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} agg\_result : *aggregate\_results) \{}
\DoxyCodeLine{            std::cout << agg\_result;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (i < aggregate\_results-\/>size() -\/ 1) \{}
\DoxyCodeLine{                std::cout << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{            \}}
\DoxyCodeLine{}
\DoxyCodeLine{            ++i;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}]"{}} << std::endl;}

\end{DoxyCodeInclude}


After using the view analysis results, its resources must be {\bfseries{relinquished}} . 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Memory resource cleanup.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// destroy vector<float>}}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (aggregate\_results) \{}
\DoxyCodeLine{            \textcolor{keyword}{delete} aggregate\_results;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


From here, please review the example at \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} for instructions~\newline
 on how to free the remainder of the resources used for the view analysis --~\newline
 which are the (vector\texorpdfstring{$<$}{<}\mbox{\hyperlink{a01351}{HF\+::\+Geometry\+::\+Mesh\+Info}}\texorpdfstring{$>$}{>} $\ast$) and (\mbox{\hyperlink{}{HF\+::\+Raytracer\+::\+Embree\+Ray\+Tracer}} $\ast$) instances.

{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Load\+OBJ loaded mesh successfully into loaded\+\_\+obj at address 00000293CC9\+C8650, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Create\+Raytracer created Embree\+Ray\+Tracer successfully into bvh at address 00000293C3012\+D20, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} \mbox{[}7.\+43102, 0, 0\mbox{]}}~\newline


Definition at line \mbox{\hyperlink{a00440_source_l00017}{17}} of file \mbox{\hyperlink{a00440_source}{view\+\_\+analysis\+\_\+\+C.\+cpp}}.



References \mbox{\hyperlink{a00176_source_l00032}{HF\+::\+Exceptions\+::\+OK}}, and \mbox{\hyperlink{a00023_source_l00484}{HF\+::\+View\+Analysis\+::\+Spherical\+Rayshoot\+With\+Any\+RTFor\+Distance()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00459_gab6b8e3eab649b42ac014fb7d02d54892_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00459_gaa4c5714c1e557ef83a03d447eb30c6d0}\label{a00459_gaa4c5714c1e557ef83a03d447eb30c6d0}} 
\index{ViewAnalysis@{ViewAnalysis}!SphereicalViewAnalysisAggregateFlat@{SphereicalViewAnalysisAggregateFlat}}
\index{SphereicalViewAnalysisAggregateFlat@{SphereicalViewAnalysisAggregateFlat}!ViewAnalysis@{ViewAnalysis}}
\doxysubsubsection{\texorpdfstring{SphereicalViewAnalysisAggregateFlat()}{SphereicalViewAnalysisAggregateFlat()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} Sphereical\+View\+Analysis\+Aggregate\+Flat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$}]{ERT,  }\item[{const float $\ast$}]{node\+\_\+ptr,  }\item[{int}]{node\+\_\+size,  }\item[{int}]{max\+\_\+rays,  }\item[{float}]{upward\+\_\+fov,  }\item[{float}]{downward\+\_\+fov,  }\item[{float}]{height,  }\item[{\mbox{\hyperlink{a00443_a8a1aa9474094ff70818051c921c0537f}{AGGREGATE\+\_\+\+TYPE}}}]{AT,  }\item[{std\+::vector$<$ float $>$ $\ast$$\ast$}]{out\+\_\+scores,  }\item[{float $\ast$$\ast$}]{out\+\_\+scores\+\_\+ptr,  }\item[{int $\ast$}]{out\+\_\+scores\+\_\+size }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00443}{Cinterface/view\+\_\+analysis\+\_\+\+C.\+h}}$>$}



Conduct view analysis, and aggregate the results. 


\begin{DoxyParams}{Parameters}
{\em ERT} & Raytracer containing the geometry to use for ray intersections. \\
\hline
{\em node\+\_\+ptr} & Observer points for the view analysis. Each 3 floats represent the \{x, y, z\} of a new node. \\
\hline
{\em node\+\_\+size} & Number of nodes in the array pointed to by node\+\_\+ptr.\\
\hline
{\em max\+\_\+rays} & Number of rays to cast for each node in node\+\_\+ptr. Note that this may cast fewer rays than max\+\_\+rays depending on fov restrictions.\\
\hline
{\em upward\+\_\+fov} & Maximum degrees upward from the viewer\textquotesingle{}s eye level to consider. \\
\hline
{\em downward\+\_\+fov} & Maximum degrees downward from the viewer\textquotesingle{}s eye level to consider. \\
\hline
{\em height} & Height to offset nodes from the ground (+Z direction). \\
\hline
{\em AT} & Type of aggregation method to use. \\
\hline
{\em out\+\_\+scores} & Output parameter for node scores. \\
\hline
{\em out\+\_\+scores\+\_\+ptr} & Pointer to the data of out\+\_\+scores. \\
\hline
{\em out\+\_\+scores\+\_\+size} & Size of out\+\_\+scores\+\_\+ptr.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
HF\+::\+OK on completion.
\end{DoxyReturn}
Similar to Spherical\+View\+Analysis but uses a flat array of floats instead of an array of nodes. This is to make the Spherical\+View\+Analysis function more accessible.

\begin{DoxyParagraph}{Caller\textquotesingle{}s Responsibility}
The caller must call \mbox{\hyperlink{a00410_af77723a4383b278169e80cf0e361ec44}{Destroy\+Float\+Vector}} with out\+\_\+scores to free the memory allocated by this function.
\end{DoxyParagraph}
\begin{DoxyPrecond}{Precondition}
1) ERT points to a valid raytracer created by Create\+Raytracer. 

2) node\+\_\+ptr contains a valid array of floats with length equal to node\+\_\+size $\ast$ 3. 

3) out\+\_\+scores, out\+\_\+scores\+\_\+ptr, and out\+\_\+score\+\_\+size are not null.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
1) out\+\_\+scores contains a pointer to score for every node in nodes in order. 

2) out\+\_\+scores\+\_\+ptr cpoints to a valid array of scores. 

3) out\+\_\+scores\+\_\+size is updated to the length of the data held by out\+\_\+scores\+\_\+ptr.
\end{DoxyPostcond}
\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000031}{Todo}}]Is there any situation where out\+\_\+scores\+\_\+size is smaller than node\+\_\+size?\end{DoxyRefDesc}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00455_mesh_setup}{Mesh setup}} (how to create a mesh), \mbox{\hyperlink{a00455_mesh_teardown}{Mesh teardown}} (how to destroy a mesh) 

\mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}} (how to create a BVH), \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} (how to destroy a BVH)
\end{DoxySeeAlso}
Begin by {\bfseries{loading an .obj file}} (\mbox{\hyperlink{a00455_mesh_setup}{Mesh setup}}).~\newline
 Then, {\bfseries{create a BVH}} (\mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}}) using the {\bfseries{mesh}}.~\newline


\begin{DoxyParagraph}{Example}

\end{DoxyParagraph}
Set up the parameters for the view analysis. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Preparing the parameters for SphericalViewAnalysisAggregateFlat}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Define point to start ray}}
\DoxyCodeLine{        \textcolor{comment}{// These are Cartesian coordinates.}}
\DoxyCodeLine{        std::array<float, 3> p1 \{ 0.0f, 0.0f, 2.0f \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Define direction to cast ray}}
\DoxyCodeLine{        \textcolor{comment}{// These are vector components, not Cartesian coordinates.}}
\DoxyCodeLine{        std::array<float, 3> dir \{ 0.0f, 0.0f, -\/1.0f \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// This is a container of nodes to be analyzed.}}
\DoxyCodeLine{        \textcolor{comment}{// SphericalViewAnalysisAggregateFlat accepts a (Node *) parameter,}}
\DoxyCodeLine{        \textcolor{comment}{// so a raw stack-\/allocated array will suffice.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// This may also be a pointer to a heap-\/allocated buffer}}
\DoxyCodeLine{        \textcolor{comment}{// (which is owned by a vector<Node>, accessed via the vector<Node>::data() method).}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// ...or, it can be a pointer to memory allocated by the caller via operator new[node\_count]}}
\DoxyCodeLine{        \textcolor{comment}{// (if this route is taken, be sure to release the memory with operator delete[] after use)}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{int} node\_count = 1;           \textcolor{comment}{// should be the element count in nodes}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} ray\_count = 1000;               \textcolor{comment}{// will be mutated by SphericalViewAnalysisAggregateFlat}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} height = 1.7f;          \textcolor{comment}{// height to offset nodes from the ground, in meters}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} upward\_fov = 50.0f;     \textcolor{comment}{// default parameter is 50.0f in Python code}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} downward\_fov = 70.0f;   \textcolor{comment}{// default parameter is 70.0f in Python code}}

\end{DoxyCodeInclude}


Now you must prepare a pointer to a std\+::vector$<$float$>$, where the {\bfseries{aggregation results}} will be stored.~\newline
 You must also select the aggregate type. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Declare a pointer to vector<float>, named aggregate\_results.}}
\DoxyCodeLine{        \textcolor{comment}{// This pointer will point to memory on the free store,}}
\DoxyCodeLine{        \textcolor{comment}{// allocated within SphericalViewAnalysisAggregateFlat.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// aggregate\_results\_data will point to the underlying buffer within *aggregate\_results,}}
\DoxyCodeLine{        \textcolor{comment}{// which will be assigned inside SphericalViewAnalysisNoAggregateFlat.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Note that we must call operator delete on aggregate\_results when we are finished with it.}}
\DoxyCodeLine{        std::vector<float>* aggregate\_results = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{        \textcolor{keywordtype}{float}* aggregate\_results\_data = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Will be equal to aggregate\_results-\/>size();}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} aggregate\_results\_size = -\/1;}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Select the aggregate type.}}
\DoxyCodeLine{        \textcolor{comment}{// This determines how to aggregate the edges within the results of the view analysis.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// AGGREGATE\_TYPE::AVERAGE means that the edges will be aggregated}}
\DoxyCodeLine{        \textcolor{comment}{// by the maximum distance from the origin point to its hit points.}}
\DoxyCodeLine{        \mbox{\hyperlink{a00443_a8a1aa9474094ff70818051c921c0537f}{AGGREGATE\_TYPE}} agg\_type = \mbox{\hyperlink{a00443_a8a1aa9474094ff70818051c921c0537fa16de38737a9f8366e9b2042b4e9b6290}{AGGREGATE\_TYPE::AVERAGE}};}

\end{DoxyCodeInclude}


Now we are ready to call \mbox{\hyperlink{}{Spherical\+View\+Analysis\+Aggregate\+Flat}} . 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00459_gaa4c5714c1e557ef83a03d447eb30c6d0}{SphereicalViewAnalysisAggregateFlat}}(bvh,}
\DoxyCodeLine{            p1.data(), node\_count, ray\_count,}
\DoxyCodeLine{            upward\_fov, downward\_fov, height,}
\DoxyCodeLine{            agg\_type,}
\DoxyCodeLine{            \&aggregate\_results, \&aggregate\_results\_data, \&aggregate\_results\_size);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at SphereicalViewAnalysisAggregateFlat, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


We can output the contents of the {\bfseries{aggregate results vector}} to {\bfseries{stdout}}. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Print aggregate results vector (vector<float>)}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{        \textcolor{keywordtype}{int} i = 0;}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} agg\_result : *aggregate\_results) \{}
\DoxyCodeLine{            std::cout << agg\_result;}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (i < aggregate\_results-\/>size() -\/ 1) \{}
\DoxyCodeLine{                std::cout << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{            \}}
\DoxyCodeLine{}
\DoxyCodeLine{            ++i;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}]"{}} << std::endl;}

\end{DoxyCodeInclude}


After using the view analysis results, its resources must be {\bfseries{relinquished}}. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Memory resource cleanup.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// destroy vector<float>}}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (aggregate\_results) \{}
\DoxyCodeLine{            \textcolor{keyword}{delete} aggregate\_results;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


From here, please review the example at \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} for instructions~\newline
 on how to free the remainder of the resources used for the view analysis --~\newline
 which are the (vector\texorpdfstring{$<$}{<}\mbox{\hyperlink{a01351}{HF\+::\+Geometry\+::\+Mesh\+Info}}\texorpdfstring{$>$}{>} $\ast$) and (\mbox{\hyperlink{}{HF\+::\+Raytracer\+::\+Embree\+Ray\+Tracer}} $\ast$) instances.

{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Load\+OBJ loaded mesh successfully into loaded\+\_\+obj at address 00000293CC9\+C84\+D0, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Create\+Raytracer created Embree\+Ray\+Tracer successfully into bvh at address 00000293C3012\+D20, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} \mbox{[}7.\+43102\mbox{]}}~\newline


Definition at line \mbox{\hyperlink{a00440_source_l00050}{50}} of file \mbox{\hyperlink{a00440_source}{view\+\_\+analysis\+\_\+\+C.\+cpp}}.



References \mbox{\hyperlink{a00245_source_l00024}{Convert\+Raw\+Float\+Array\+To\+Points()}}, \mbox{\hyperlink{a00176_source_l00032}{HF\+::\+Exceptions\+::\+OK}}, and \mbox{\hyperlink{a00023_source_l00484}{HF\+::\+View\+Analysis\+::\+Spherical\+Rayshoot\+With\+Any\+RTFor\+Distance()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00459_gaa4c5714c1e557ef83a03d447eb30c6d0_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00459_gaf572b7bec28d55bf2c72719742703dff}\label{a00459_gaf572b7bec28d55bf2c72719742703dff}} 
\index{ViewAnalysis@{ViewAnalysis}!SphericalDistribute@{SphericalDistribute}}
\index{SphericalDistribute@{SphericalDistribute}!ViewAnalysis@{ViewAnalysis}}
\doxysubsubsection{\texorpdfstring{SphericalDistribute()}{SphericalDistribute()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} Spherical\+Distribute (\begin{DoxyParamCaption}\item[{int $\ast$}]{num\+\_\+rays,  }\item[{std\+::vector$<$ float $>$ $\ast$$\ast$}]{out\+\_\+direction\+\_\+vector,  }\item[{float $\ast$$\ast$}]{out\+\_\+direction\+\_\+data,  }\item[{float}]{upward\+\_\+fov,  }\item[{float}]{downward\+\_\+fov }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00443}{Cinterface/view\+\_\+analysis\+\_\+\+C.\+h}}$>$}



Equally distribute points around a unit sphere. 


\begin{DoxyParams}{Parameters}
{\em num\+\_\+rays} & Number of points to distribute.\\
\hline
{\em out\+\_\+direction\+\_\+vector} & Output parameter for points generated. Every 3 floats represents a new point.\\
\hline
{\em out\+\_\+direction\+\_\+data} & pointer to the data of out\+\_\+direction\+\_\+vector \\
\hline
{\em upward\+\_\+fov} & Maximum degrees upward from the viewer\textquotesingle{}s eye level to consider. \\
\hline
{\em downward\+\_\+fov} & Maximum degrees downward from the viewer\textquotesingle{}s eye level to consider.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
HF\+::\+OK on completion.
\end{DoxyReturn}
\begin{DoxyParagraph}{Caller\textquotesingle{}s Responsibility}
The caller must call \mbox{\hyperlink{a00410_af77723a4383b278169e80cf0e361ec44}{Destroy\+Float\+Vector}} with out\+\_\+direction\+\_\+vector to free the memory allocated by this function.
\end{DoxyParagraph}
\begin{DoxyRemark}{Remarks}
This function is used internally by all view analysis functions to equally distribute the directions each ray will be casted in.
\end{DoxyRemark}
\begin{DoxyPrecond}{Precondition}
out\+\_\+direction\+\_\+vector and out\+\_\+direction\+\_\+data must not be null, but the pointers they hold can be null.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
1) The pointer pointed to by out\+\_\+direction\+\_\+vector contains a vector of directions.

2) num\+\_\+rays contains the number of points distributed by this function. This may be more or less than the original number depending on the limitations specified by upward and downward fov.
\end{DoxyPostcond}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} (how to destroy a BVH) 

\mbox{\hyperlink{a00455_mesh_teardown}{Mesh teardown}} (how to destroy a mesh)
\end{DoxySeeAlso}
\begin{DoxyParagraph}{Example}

\end{DoxyParagraph}
Begin by {\bfseries{initializing}} input values\+:~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Set arguments}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} num\_rays = 10;                          \textcolor{comment}{// number of points to distribute}}
\DoxyCodeLine{        std::vector<float>* out\_float = \textcolor{keyword}{nullptr};    \textcolor{comment}{// output parameter for points generated}}
\DoxyCodeLine{        \textcolor{keywordtype}{float}* out\_float\_data;                      \textcolor{comment}{// pointer to buffer within *out\_float}}
\DoxyCodeLine{        \textcolor{keywordtype}{float} up\_fov = 90.0f;                       \textcolor{comment}{// max degrees upward from viewer's eye level to consider}}
\DoxyCodeLine{        \textcolor{keywordtype}{float} down\_fov = 90.0f;                     \textcolor{comment}{// max degrees downward from viewer's eye level to consider}}

\end{DoxyCodeInclude}


We are now ready to call \mbox{\hyperlink{a00459_gaf572b7bec28d55bf2c72719742703dff}{Spherical\+Distribute}} . 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Call function}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{keyword}{auto} status = \mbox{\hyperlink{a00459_gaf572b7bec28d55bf2c72719742703dff}{SphericalDistribute}}(}
\DoxyCodeLine{            \&num\_rays,}
\DoxyCodeLine{            \&out\_float,}
\DoxyCodeLine{            \&out\_float\_data,}
\DoxyCodeLine{            up\_fov,}
\DoxyCodeLine{            down\_fov}
\DoxyCodeLine{        );}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at SphericalDistribute, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


Let\textquotesingle{}s output the result, stored in {\bfseries{out\+\_\+float\+\_\+data}} (you can also access {\bfseries{$\ast$out\+\_\+float}}). 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Print results}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}Number of rays: "{}} << num\_rays << std::endl;}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_rays; i++) \{}
\DoxyCodeLine{            \textcolor{keywordtype}{int} os = i * 3;}
\DoxyCodeLine{}
\DoxyCodeLine{            std::cout << \textcolor{stringliteral}{"{}("{}}}
\DoxyCodeLine{                << out\_float\_data[os] << \textcolor{stringliteral}{"{}, "{}}}
\DoxyCodeLine{                << out\_float\_data[os + 1] << \textcolor{stringliteral}{"{}, "{}}}
\DoxyCodeLine{                << out\_float\_data[os + 2] << \textcolor{stringliteral}{"{})"{}}}
\DoxyCodeLine{                << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


Make sure to destroy the resources addressed by {\bfseries{out\+\_\+float}} when you are finished with it. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Deallocate Memory}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \mbox{\hyperlink{a00410_af77723a4383b278169e80cf0e361ec44}{DestroyFloatVector}}(out\_float);}

\end{DoxyCodeInclude}


{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Number of rays\+: 10}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (-\/0, -\/1, 0)}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (-\/0.\+276545, -\/0.\+8, -\/0.\+532469)}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (0.\+751457, -\/0.\+6, 0.\+27443)}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (-\/0.\+847177, -\/0.\+4, 0.\+349703)}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (0.\+415282, -\/0.\+2, -\/0.\+887435)}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (0.\+299284, 0, 0.\+954164)}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (-\/0.\+847731, 0.\+2, -\/0.\+491275)}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (0.\+895138, 0.\+4, -\/0.\+196795)}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (-\/0.\+460102, 0.\+6, 0.\+654451)}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (-\/0.\+0771074, 0.\+8, -\/0.\+595025)}~\newline


Definition at line \mbox{\hyperlink{a00440_source_l00126}{126}} of file \mbox{\hyperlink{a00440_source}{view\+\_\+analysis\+\_\+\+C.\+cpp}}.



References \mbox{\hyperlink{a00020_source_l00121}{HF\+::\+View\+Analysis\+::\+Fibbonacci\+Distribute\+Points()}}, and \mbox{\hyperlink{a00176_source_l00032}{HF\+::\+Exceptions\+::\+OK}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00459_gaf572b7bec28d55bf2c72719742703dff_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00459_ga78f77d24531d0fa55c9b60d7ec1bf32a}\label{a00459_ga78f77d24531d0fa55c9b60d7ec1bf32a}} 
\index{ViewAnalysis@{ViewAnalysis}!SphericalRayshootWithAnyRTForDistance@{SphericalRayshootWithAnyRTForDistance}}
\index{SphericalRayshootWithAnyRTForDistance@{SphericalRayshootWithAnyRTForDistance}!ViewAnalysis@{ViewAnalysis}}
\doxysubsubsection{\texorpdfstring{SphericalRayshootWithAnyRTForDistance()}{SphericalRayshootWithAnyRTForDistance()}}
{\footnotesize\ttfamily template$<$typename RT , typename N $>$ \\
std\+::vector$<$ float $>$ HF\+::\+View\+Analysis\+::\+Spherical\+Rayshoot\+With\+Any\+RTFor\+Distance (\begin{DoxyParamCaption}\item[{RT \&}]{ray\+\_\+tracer,  }\item[{const std\+::vector$<$ N $>$ \&}]{Nodes,  }\item[{int}]{num\+\_\+rays,  }\item[{float}]{upward\+\_\+limit = {\ttfamily 50.0f},  }\item[{float}]{downward\+\_\+limit = {\ttfamily 70.0f},  }\item[{float}]{height = {\ttfamily 1.7f},  }\item[{const \mbox{\hyperlink{a00466_a1fcaa17d2a8df8896a3b0447973bd07b}{AGGREGATE\+\_\+\+TYPE}}}]{aggregation = {\ttfamily \mbox{\hyperlink{a00466_a1fcaa17d2a8df8896a3b0447973bd07ba6970bdc2201030b9c03fbdcf3973858a}{AGGREGATE\+\_\+\+TYPE\+::\+SUM}}} }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00023}{Cpp/analysismethods/src/view\+\_\+analysis.\+h}}$>$}



Conduct view analysis and recieve a summarized set of results for each node.  


\begin{DoxyParams}{Parameters}
{\em ray\+\_\+tracer} & A valid raytracer that already has the geometry loaded. \\
\hline
{\em Nodes} & Points to perform analysis from. \\
\hline
{\em num\+\_\+rays} & The number of rays to cast from each point in nodes. The actual amount of rays cast may be less or more than this number. Due to how the spherical ray distribution is calculated. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em upward\+\_\+limit} & Maximum angle in degrees to cast rays above the viewpoint. \\
\hline
{\em downward\+\_\+limit} & Maximum angle in degrees to cast rays below the viewpoint. \\
\hline
{\em height} & Height off the ground to cast from. All points in Nodes will be offset this distance from the ground (+Z) before calculations are performed \\
\hline
{\em aggregation} & The type of aggregation to use.\\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em RT} & A Raytracer with Intersect\+Output\+Arguments defined for the type of N. \\
\hline
{\em N} & A point that overloads \mbox{[}\mbox{]} for 0, 1 and 2.\\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
A Nodes.\+size() long array of results for each node in Nodes.
\end{DoxyReturn}
The analysis performed by this function is identical to that described in Spherical\+View\+Analysis, but results are summarized over the course of the analysis for every observer point instead of recording each individual intersection. The memory usage for this function is drastically lower than that of Spherical\+View\+Analysis, resulting in lower execution times at the cost of being restricted to a set of predefined aggregation methods.


\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+array\+\_\+new\+\_\+length} & The number of rays is larger than that which can be stored in a std\+::vector.\\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00459_ga6ca336e3887ef82d17b0713c2bf862df}{Fibbonacci\+Distribute\+Points}} For details on how the directions are calculated from num\+\_\+rays. 

\mbox{\hyperlink{a00459_gaecaa04882696ac6d73173227bd28e91b}{Spherical\+View\+Analysis}} to get the result of every ray cast instead of summarizing the results. 

\mbox{\hyperlink{a00466_a1fcaa17d2a8df8896a3b0447973bd07b}{AGGREGATE\+\_\+\+TYPE}} for a list of aggregation methods. 

\mbox{\hyperlink{a00466_a38c197b654c753cb656ab60e88d65120}{Aggregate}} for the implementation of all aggregation methods.
\end{DoxySeeAlso}
\begin{DoxyParagraph}{Example}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Requires \#include "{}view\_analysis.h"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Use this so we can fit within 80 characters}}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{a00459_ga78f77d24531d0fa55c9b60d7ec1bf32a}{HF::ViewAnalysis::SphericalRayshootWithAnyRTForDistance}};}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{a00466_a1fcaa17d2a8df8896a3b0447973bd07b}{HF::ViewAnalysis::AGGREGATE\_TYPE}};}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{a01411}{HF::RayTracer::EmbreeRayTracer}};}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{a01351}{HF::Geometry::MeshInfo}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create Plane}}
\DoxyCodeLine{\textcolor{keyword}{const} std::vector<float> plane\_vertices\{}
\DoxyCodeLine{    -\/10.0f, 10.0f, 0.0f,}
\DoxyCodeLine{    -\/10.0f, -\/10.0f, 0.0f,}
\DoxyCodeLine{    10.0f, 10.0f, 0.0f,}
\DoxyCodeLine{    10.0f, -\/10.0f, 0.0f,}
\DoxyCodeLine{\};}
\DoxyCodeLine{\textcolor{keyword}{const} std::vector<int> plane\_indices\{ 3, 1, 0, 2, 3, 0 \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create RayTracer}}
\DoxyCodeLine{EmbreeRayTracer ert(std::vector<MeshInfo>\{}
\DoxyCodeLine{    \mbox{\hyperlink{a00428_acea841c68a73d07ad9d772ec2e94a683}{MeshInfo}}(plane\_vertices, plane\_indices, 0, \textcolor{stringliteral}{"{} "{}})\}}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Define observer points}}
\DoxyCodeLine{std::vector<std::array<float, 3>> points\{}
\DoxyCodeLine{    \{0,0,0\}, \{10,10,0\}, \{20,20,0\}, \{30, 30, 0\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Perform View Analysis and sum the distance to all intersections}}
\DoxyCodeLine{\textcolor{comment}{// for every node}}
\DoxyCodeLine{\textcolor{keywordtype}{int} num\_rays = 2000;}
\DoxyCodeLine{\textcolor{keyword}{auto} results = \mbox{\hyperlink{a00459_ga78f77d24531d0fa55c9b60d7ec1bf32a}{SphericalRayshootWithAnyRTForDistance}}(}
\DoxyCodeLine{    ert, points, num\_rays, 90.0f, 90.0f, 1.7f, \mbox{\hyperlink{a00466_a1fcaa17d2a8df8896a3b0447973bd07ba6970bdc2201030b9c03fbdcf3973858a}{AGGREGATE\_TYPE::SUM}}}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Print Results}}
\DoxyCodeLine{std::cerr << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < results.size(); i++) \{}
\DoxyCodeLine{    std::cerr << results[i];}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (i != results.size() -\/ 1) std::cerr << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{\}}
\DoxyCodeLine{std::cerr << \textcolor{stringliteral}{"{})"{}} << std::endl;}

\end{DoxyCode}

\end{DoxyParagraph}
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (2746.\+72, 932.\+565, 170.\+858, 76.\+8413)}

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000005}{Todo}}]Should this have a height check like the one in the \mbox{\hyperlink{a00467}{Visibility\+Graph}}?\end{DoxyRefDesc}


\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000006}{Todo}}]Rename this to View\+Analysis\+Aggregate.\end{DoxyRefDesc}


\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000007}{Todo}}]Potential speed up here by using a Raytracer function that doesn\textquotesingle{}t return the point of intersection. \end{DoxyRefDesc}


Definition at line \mbox{\hyperlink{a00023_source_l00484}{484}} of file \mbox{\hyperlink{a00023_source}{view\+\_\+analysis.\+h}}.



References \mbox{\hyperlink{a00023_source_l00194}{HF\+::\+View\+Analysis\+::\+Aggregate()}}, \mbox{\hyperlink{a00020_source_l00121}{HF\+::\+View\+Analysis\+::\+Fibbonacci\+Distribute\+Points()}}, and \mbox{\hyperlink{a00466_a1fcaa17d2a8df8896a3b0447973bd07bace31e2a082d17e038fcc6e3006166653}{HF\+::\+View\+Analysis\+::\+MIN}}.



Referenced by \mbox{\hyperlink{a00440_source_l00017}{Sphereical\+View\+Analysis\+Aggregate()}}, and \mbox{\hyperlink{a00440_source_l00050}{Sphereical\+View\+Analysis\+Aggregate\+Flat()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00459_ga78f77d24531d0fa55c9b60d7ec1bf32a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00459_ga78f77d24531d0fa55c9b60d7ec1bf32a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00459_gaecaa04882696ac6d73173227bd28e91b}\label{a00459_gaecaa04882696ac6d73173227bd28e91b}} 
\index{ViewAnalysis@{ViewAnalysis}!SphericalViewAnalysis@{SphericalViewAnalysis}}
\index{SphericalViewAnalysis@{SphericalViewAnalysis}!ViewAnalysis@{ViewAnalysis}}
\doxysubsubsection{\texorpdfstring{SphericalViewAnalysis()}{SphericalViewAnalysis()}}
{\footnotesize\ttfamily template$<$typename RES , typename RT , typename N $>$ \\
std\+::vector$<$ RES $>$ HF\+::\+View\+Analysis\+::\+Spherical\+View\+Analysis (\begin{DoxyParamCaption}\item[{RT \&}]{ray\+\_\+tracer,  }\item[{const std\+::vector$<$ N $>$ \&}]{Nodes,  }\item[{int}]{num\+\_\+rays,  }\item[{float}]{upward\+\_\+limit = {\ttfamily 50.0f},  }\item[{float}]{downward\+\_\+limit = {\ttfamily 70.0f},  }\item[{float}]{height = {\ttfamily 1.7f} }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00023}{Cpp/analysismethods/src/view\+\_\+analysis.\+h}}$>$}



Conduct view analysis with any Raytracer in parallel.  


\begin{DoxyParams}{Parameters}
{\em ray\+\_\+tracer} & A valid raytracer that already has the geometry loaded. \\
\hline
{\em Nodes} & Points to perform analysis from. \\
\hline
{\em num\+\_\+rays} & The number of rays to cast from each point in nodes. The actual amount of rays cast may be less or more than this number. Due to how the spherical ray distribution is calculated. \\
\hline
{\em upward\+\_\+limit} & Maximum angle in degrees to cast rays above the viewpoint. \\
\hline
{\em downward\+\_\+limit} & Maximum angle in degrees to cast rays below the viewpoint. \\
\hline
{\em height} & Height off the ground to cast from. All points in Nodes will be offset this distance from the ground (+Z) before calculations are performed\\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em RES} & A class or struct that has a .Set\+Hit() function. This function will be called with the node, direction, distance to intersection, and Mesh\+ID intersected for every ray that intersects geometry.\\
\hline
{\em RT} & A Raytracer with Intersect\+Output\+Arguments defined for the type of N. \\
\hline
{\em N} & A point that overloads \mbox{[}\mbox{]} for 0, 1 and 2.\\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
An {\itshape approximately} num\+\_\+rays $\ast$ Nodes.\+size() long vector of RES with one element for every ray cast. Results will be laid out in order with the first node\textquotesingle{}s results first, then the second, etc. Every ray that intersected something, and all elements that didn\textquotesingle{}t result in an intersection will left at their default values.
\end{DoxyReturn}
\mbox{\hyperlink{a00466}{View\+Analysis}} is calculated by casting a series of rays equally distributed in a sphere from each point in Nodes. This function will run in parallel using all available cores. Depending on RES, this function\textquotesingle{}s complexity and results can vary.


\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+array\+\_\+new\+\_\+length} & The number of rays is larger than that which can be stored in a std\+::vector.\\
\hline
\end{DoxyExceptions}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00459_ga6ca336e3887ef82d17b0713c2bf862df}{Fibbonacci\+Distribute\+Points}} For details on how the directions are calculated from num\+\_\+rays. 

\mbox{\hyperlink{a00459_ga78f77d24531d0fa55c9b60d7ec1bf32a}{Spherical\+Rayshoot\+With\+Any\+RTFor\+Distance}} for a more efficent method of getting a summary of the results.
\end{DoxySeeAlso}
\begin{DoxyParagraph}{Example}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Requires \#include "{}view\_analysis.h"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Use this so we can fit within 80 characters}}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{a00459_gaecaa04882696ac6d73173227bd28e91b}{HF::ViewAnalysis::SphericalViewAnalysis}};}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{a01411}{HF::RayTracer::EmbreeRayTracer}};}
\DoxyCodeLine{\textcolor{keyword}{using }\mbox{\hyperlink{a01351}{HF::Geometry::MeshInfo}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create Plane}}
\DoxyCodeLine{\textcolor{keyword}{const} std::vector<float> plane\_vertices\{}
\DoxyCodeLine{    -\/10.0f, 10.0f, 0.0f,}
\DoxyCodeLine{    -\/10.0f, -\/10.0f, 0.0f,}
\DoxyCodeLine{    10.0f, 10.0f, 0.0f,}
\DoxyCodeLine{    10.0f, -\/10.0f, 0.0f,}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} std::vector<int> plane\_indices\{ 3, 1, 0, 2, 3, 0 \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create RayTracer}}
\DoxyCodeLine{EmbreeRayTracer ert(std::vector<MeshInfo>\{}
\DoxyCodeLine{    \mbox{\hyperlink{a00428_acea841c68a73d07ad9d772ec2e94a683}{MeshInfo}}(plane\_vertices, plane\_indices, 0, \textcolor{stringliteral}{"{} "{}})\}}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Define a struct that only stores the distance when sethit is called.}}
\DoxyCodeLine{\textcolor{keyword}{struct }SampleResults \{}
\DoxyCodeLine{    \textcolor{keywordtype}{float} dist = -\/1.0f;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{inline} \textcolor{keywordtype}{void} SetHit(}
\DoxyCodeLine{        \textcolor{keyword}{const} std::array<float, 3> \& node,}
\DoxyCodeLine{        \textcolor{keyword}{const} std::array<float, 3> \& direction,}
\DoxyCodeLine{        \textcolor{keywordtype}{float} distance,}
\DoxyCodeLine{        \textcolor{keywordtype}{int} meshID}
\DoxyCodeLine{    ) \{}
\DoxyCodeLine{        dist = distance;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Define observer points}}
\DoxyCodeLine{std::vector<std::array<float, 3>> points\{}
\DoxyCodeLine{    \{0,0,0\}, \{1,1,0\}, \{1,2,0\}, \{1000, 1000, 0\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Perform View Analysis}}
\DoxyCodeLine{\textcolor{keywordtype}{int} num\_rays = 50;}
\DoxyCodeLine{\textcolor{keyword}{auto} results = SphericalViewAnalysis<SampleResults>(ert, points, num\_rays);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Determine how many directions there were since there may have been less than}}
\DoxyCodeLine{\textcolor{comment}{// what we specified}}
\DoxyCodeLine{\textcolor{keywordtype}{int} num\_directions = results.size() / points.size();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Construct a vector from the results of the first node}}
\DoxyCodeLine{std::vector<SampleResults> first\_results(}
\DoxyCodeLine{    results.begin(), results.begin() + num\_directions}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Print Results}}
\DoxyCodeLine{std::cerr << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < first\_results.size(); i++) \{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto} \& result = first\_results[i];}
\DoxyCodeLine{    std::cerr << result.dist;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (i != first\_results.size() -\/ 1) std::cerr << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{\}}
\DoxyCodeLine{std::cerr << \textcolor{stringliteral}{"{})"{}} << std::endl;}

\end{DoxyCode}

\end{DoxyParagraph}
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} (-\/1, 7.\+35812, -\/1, -\/1, 3.\+70356, -\/1, 5.\+56647, 12.\+1517, -\/1, 2.\+36725, -\/1, -\/1, 2.\+97477, 2.\+58713, -\/1,} {\ttfamily -\/1, 1.\+91404, 5.\+95885, 4.\+26368, 1.\+86167, -\/1, -\/1, 2.\+0406, 2.\+78304, -\/1, -\/1, -\/1, -\/1, 2.\+83909, 2.\+05302,} {\ttfamily -\/1, -\/1, 1.\+90724, 4.\+29017, 6.\+3381, 1.\+98544, -\/1, -\/1, 2.\+75554, 3.\+15929, -\/1, -\/1, 2.\+6345, -\/1, -\/1,} {\ttfamily 6.\+80486, -\/1, 5.\+12012, -\/1)}

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000004}{Todo}}]Should this have a height check like the one in the \mbox{\hyperlink{a00467}{Visibility\+Graph}}?\end{DoxyRefDesc}


Definition at line \mbox{\hyperlink{a00023_source_l00335}{335}} of file \mbox{\hyperlink{a00023_source}{view\+\_\+analysis.\+h}}.



References \mbox{\hyperlink{a00020_source_l00121}{HF\+::\+View\+Analysis\+::\+Fibbonacci\+Distribute\+Points()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00459_gaecaa04882696ac6d73173227bd28e91b_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00459_ga94d3ddc3981020e2852fc77e51266185}\label{a00459_ga94d3ddc3981020e2852fc77e51266185}} 
\index{ViewAnalysis@{ViewAnalysis}!SphericalViewAnalysisNoAggregate@{SphericalViewAnalysisNoAggregate}}
\index{SphericalViewAnalysisNoAggregate@{SphericalViewAnalysisNoAggregate}!ViewAnalysis@{ViewAnalysis}}
\doxysubsubsection{\texorpdfstring{SphericalViewAnalysisNoAggregate()}{SphericalViewAnalysisNoAggregate()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} Spherical\+View\+Analysis\+No\+Aggregate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$}]{ERT,  }\item[{const \mbox{\hyperlink{a02071}{HF\+::\+Spatial\+Structures\+::\+Node}} $\ast$}]{node\+\_\+ptr,  }\item[{int}]{node\+\_\+size,  }\item[{int $\ast$}]{max\+\_\+rays,  }\item[{float}]{upward\+\_\+fov,  }\item[{float}]{downward\+\_\+fov,  }\item[{float}]{height,  }\item[{std\+::vector$<$ \mbox{\hyperlink{a02087}{Ray\+Result}} $>$ $\ast$$\ast$}]{out\+\_\+results,  }\item[{\mbox{\hyperlink{a02087}{Ray\+Result}} $\ast$$\ast$}]{out\+\_\+results\+\_\+ptr }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00443}{Cinterface/view\+\_\+analysis\+\_\+\+C.\+h}}$>$}



Perform view analysis, then get the distance and meshid for each individual ray casted. 


\begin{DoxyParams}{Parameters}
{\em ERT} & Raytracer containing the geometry to use for ray intersections. \\
\hline
{\em node\+\_\+ptr} & Observer points for the view analysis. \\
\hline
{\em node\+\_\+size} & Number of nodes in the array pointed to by node\+\_\+ptr.\\
\hline
{\em max\+\_\+rays} & Number of rays to cast for each node in node\+\_\+ptr. This will be updated with the actual number of rays casted upon completion.\\
\hline
{\em upward\+\_\+fov} & Maximum degrees upward from the viewer\textquotesingle{}s eye level to consider. \\
\hline
{\em downward\+\_\+fov} & Maximum degrees downward from the viewer\textquotesingle{}s eye level to consider. \\
\hline
{\em height} & Height to offset nodes from the ground (+Z direction). \\
\hline
{\em out\+\_\+results} & Pointer to the vector containing the results of every ray casted. \\
\hline
{\em out\+\_\+results\+\_\+ptr} & Pointer to the data of out\+\_\+results.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
HF\+::\+OK on completion.
\end{DoxyReturn}
Rays that do not intersect with any geometry will have a meshid of -\/1.

\begin{DoxyParagraph}{Caller\textquotesingle{}s Responsibility}
The caller must call \mbox{\hyperlink{a00457_ga5a68e1d668554f73ee06de8aeeaaffad}{Destroy\+Ray\+Result\+Vector}} with out\+\_\+results to free the memory allocated by this function.
\end{DoxyParagraph}
\begin{DoxyPrecond}{Precondition}
1) ERT points to a valid raytracer created by \mbox{\hyperlink{a00457_ga3ac702d080e493d1fa8be6cf4243e38b}{Create\+Raytracer}}. 

2) node\+\_\+ptr contains a valid array of nodes with length equal to node\+\_\+size. 

3) node\+\_\+ptr, max\+\_\+rays, and ERT are not null.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
1) out\+\_\+results contains a pointer to score for every node in nodes in order. 

2) out\+\_\+results\+\_\+ptr points to a valid array of scores. 

3) max\+\_\+rays is updated to the number of rays casted in the view analysis.
\end{DoxyPostcond}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00455_mesh_setup}{Mesh setup}} (how to create a mesh), \mbox{\hyperlink{a00455_mesh_teardown}{Mesh teardown}} (how to destroy a mesh) 

\mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}} (how to create a BVH), \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} (how to destroy a BVH)

\mbox{\hyperlink{a00459_gaf572b7bec28d55bf2c72719742703dff}{Spherical\+Distribute}} to get the direction of every ray casted by this function. Can be useful to determine the point of intersection for every ray casted.
\end{DoxySeeAlso}
\begin{DoxyParagraph}{Example}

\end{DoxyParagraph}
Begin by {\bfseries{loading an .obj file}} (\mbox{\hyperlink{a00455_mesh_setup}{Mesh setup}}).~\newline
 Then, {\bfseries{create a BVH}} (\mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}}) using the {\bfseries{mesh}}.~\newline


Set up the parameters for the view analysis. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Preparing the parameters for SphericalViewAnalysisNoAggregate}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Define point to start ray}}
\DoxyCodeLine{        \textcolor{comment}{// These are Cartesian coordinates.}}
\DoxyCodeLine{        std::array<Node, 1> p1\{ Node(0.0f, 0.0f, 2.0f) \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Define direction to cast ray}}
\DoxyCodeLine{        \textcolor{comment}{// These are vector components, not Cartesian coordinates.}}
\DoxyCodeLine{        std::array<float, 3> dir \{ 0.0f, 0.0f, -\/1.0f \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// This is a container of nodes to be analyzed.}}
\DoxyCodeLine{        \textcolor{comment}{// SphericalViewAnalysisNoAggregate accepts a (Node *) parameter,}}
\DoxyCodeLine{        \textcolor{comment}{// so a raw stack-\/allocated array will suffice.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// This may also be a pointer to a heap-\/allocated buffer}}
\DoxyCodeLine{        \textcolor{comment}{// (which is owned by a vector<Node>, accessed via the vector<Node>::data() method).}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// ...or, it can be a pointer to memory allocated by the caller via operator new[node\_count]}}
\DoxyCodeLine{        \textcolor{comment}{// (if this route is taken, be sure to release the memory with operator delete[] after use)}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{int} node\_count = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(p1.size()); \textcolor{comment}{// should be the element count in nodes}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} ray\_count = 1000;               \textcolor{comment}{// will be mutated by SphericalViewAnalysisNoAggregate}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} height = 1.7f;          \textcolor{comment}{// height to offset nodes from the ground, in meters}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} upward\_fov = 50.0f;     \textcolor{comment}{// default parameter is 50.0f in Python code}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} downward\_fov = 70.0f;   \textcolor{comment}{// default parameter is 70.0f in Python code}}

\end{DoxyCodeInclude}


Now you must prepare a pointer to a std\+::vector\texorpdfstring{$<$}{<}\mbox{\hyperlink{a02087}{Ray\+Result}}\texorpdfstring{$>$}{>}.~\newline
 View analysis results will be stored at the memory addressed by this pointer. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Declare a pointer to vector<RayResult>, named results.}}
\DoxyCodeLine{        \textcolor{comment}{// This pointer will point to memory on the free store,}}
\DoxyCodeLine{        \textcolor{comment}{// allocated within SphericalViewAnalysisNoAggregate.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// results\_data will point to the underlying buffer within *results,}}
\DoxyCodeLine{        \textcolor{comment}{// which will be assigned inside SphericalViewAnalysisNoAggregate.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Note that we must call operator delete on results when we are finished with it.}}
\DoxyCodeLine{        std::vector<RayResult>* results = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{        \mbox{\hyperlink{a02087}{RayResult}}* results\_data = \textcolor{keyword}{nullptr};}

\end{DoxyCodeInclude}


Now we are ready to call \mbox{\hyperlink{a00459_ga94d3ddc3981020e2852fc77e51266185}{Spherical\+View\+Analysis\+No\+Aggregate}} . 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Conducting a view analysis on the node at position p1.}}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00459_ga94d3ddc3981020e2852fc77e51266185}{SphericalViewAnalysisNoAggregate}}(bvh,}
\DoxyCodeLine{            p1.data(), node\_count, \&ray\_count,}
\DoxyCodeLine{            upward\_fov, downward\_fov, height,}
\DoxyCodeLine{            \&results, \&results\_data);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at SphericalViewAnalysisNoAggregate, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


We can output the contents of the {\bfseries{aggregate results vector}} to {\bfseries{stdout}}. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Print results vector (vector<RayResult>)}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{int} start\_range = 15;}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{int} end\_range = 20;}
\DoxyCodeLine{}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = start\_range; i < end\_range; i++) \{}
\DoxyCodeLine{            \textcolor{keyword}{auto} result = (*results)[i];}
\DoxyCodeLine{}
\DoxyCodeLine{            std::cout << \textcolor{stringliteral}{"{}("{}} << result.distance << \textcolor{stringliteral}{"{}, "{}} << result.meshid << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (i < end\_range -\/ 1) \{}
\DoxyCodeLine{                std::cout << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{            \}}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}]"{}} << std::endl;}

\end{DoxyCodeInclude}


After using the view analysis results, its resources must be {\bfseries{relinquished}}. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Memory resource cleanup.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// destroy vector<RayResult>}}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (results) \{}
\DoxyCodeLine{            \textcolor{keyword}{delete} results;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


From here, please review the example at \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} for instructions~\newline
 on how to free the remainder of the resources used for the view analysis --~\newline
 which are the (vector\texorpdfstring{$<$}{<}\mbox{\hyperlink{a01351}{HF\+::\+Geometry\+::\+Mesh\+Info}}\texorpdfstring{$>$}{>} $\ast$) and (\mbox{\hyperlink{}{HF\+::\+Raytracer\+::\+Embree\+Ray\+Tracer}} $\ast$) instances.

{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Load\+OBJ loaded mesh successfully into loaded\+\_\+obj at address 00000293CC9\+C84\+D0, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Create\+Raytracer created Embree\+Ray\+Tracer successfully into bvh at address 00000293C3012500, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} \mbox{[}(-\/1, -\/1), (-\/1, -\/1), (15.\+8334, 0), (-\/1, -\/1), (-\/1, -\/1)\mbox{]}}~\newline


Definition at line \mbox{\hyperlink{a00440_source_l00073}{73}} of file \mbox{\hyperlink{a00440_source}{view\+\_\+analysis\+\_\+\+C.\+cpp}}.



References \mbox{\hyperlink{a00176_source_l00032}{HF\+::\+Exceptions\+::\+OK}}.

\mbox{\Hypertarget{a00459_ga348af4492f3e4e7ffab6da3e86de3924}\label{a00459_ga348af4492f3e4e7ffab6da3e86de3924}} 
\index{ViewAnalysis@{ViewAnalysis}!SphericalViewAnalysisNoAggregateFlat@{SphericalViewAnalysisNoAggregateFlat}}
\index{SphericalViewAnalysisNoAggregateFlat@{SphericalViewAnalysisNoAggregateFlat}!ViewAnalysis@{ViewAnalysis}}
\doxysubsubsection{\texorpdfstring{SphericalViewAnalysisNoAggregateFlat()}{SphericalViewAnalysisNoAggregateFlat()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} Spherical\+View\+Analysis\+No\+Aggregate\+Flat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$}]{ERT,  }\item[{const float $\ast$}]{node\+\_\+ptr,  }\item[{int}]{node\+\_\+size,  }\item[{int $\ast$}]{max\+\_\+rays,  }\item[{float}]{upward\+\_\+fov,  }\item[{float}]{downward\+\_\+fov,  }\item[{float}]{height,  }\item[{std\+::vector$<$ \mbox{\hyperlink{a02087}{Ray\+Result}} $>$ $\ast$$\ast$}]{out\+\_\+results,  }\item[{\mbox{\hyperlink{a02087}{Ray\+Result}} $\ast$$\ast$}]{out\+\_\+results\+\_\+ptr }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00443}{Cinterface/view\+\_\+analysis\+\_\+\+C.\+h}}$>$}



Perform view analysis, and get the distance and meshid for each individual ray casted. 


\begin{DoxyParams}{Parameters}
{\em ERT} & Raytracer containing the geometry to use for ray intersections.\\
\hline
{\em node\+\_\+ptr} & observer points for the view analysis. Every 3 elements represents the x,y,z coordinates of a new point.\\
\hline
{\em node\+\_\+size} & number of nodes in the array pointed to by node\+\_\+ptr. Should be equal to the length of the array contained by node\+\_\+ptr $\ast$ 3.\\
\hline
{\em max\+\_\+rays} & number of rays to cast for each node in node\+\_\+ptr. This will be updated with the actual number of rays casted upon completion.\\
\hline
{\em upward\+\_\+fov} & Maximum degrees upward from the viewer\textquotesingle{}s eye level to consider. \\
\hline
{\em downward\+\_\+fov} & Maximum degrees downward from the viewer\textquotesingle{}s eye level to consider. \\
\hline
{\em height} & Height to offset nodes from the ground (+Z direction). \\
\hline
{\em out\+\_\+results} & Pointer to the vector containing the results of every ray casted. \\
\hline
{\em out\+\_\+results\+\_\+ptr} & Pointer to the data of out\+\_\+results.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
HF\+::\+OK on completion.
\end{DoxyReturn}
Rays that do not intersect with any geometry will have a meshid of -\/1.

\begin{DoxyParagraph}{Caller\textquotesingle{}s Responsibility}
The caller must call \mbox{\hyperlink{a00457_ga5a68e1d668554f73ee06de8aeeaaffad}{Destroy\+Ray\+Result\+Vector}} with out\+\_\+results to free the memory allocated by this function.
\end{DoxyParagraph}
\begin{DoxyPrecond}{Precondition}
1) ERT points to a valid raytracer created by \mbox{\hyperlink{a00457_ga3ac702d080e493d1fa8be6cf4243e38b}{Create\+Raytracer}}. 

2) node\+\_\+ptr contains a valid array of floats with length equal to node\+\_\+size $\ast$3 . 

3) node\+\_\+ptr, max\+\_\+rays, and ERT are not null.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
1) out\+\_\+scores contains a pointer to score for every node in nodes in order. 

2) out\+\_\+scores\+\_\+ptr cpoints to a valid array of scores. 

3) max\+\_\+rays is updated to the number of rays casted in the view analysis.
\end{DoxyPostcond}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00455_mesh_setup}{Mesh setup}} (how to create a mesh), \mbox{\hyperlink{a00455_mesh_teardown}{Mesh teardown}} (how to destroy a mesh) 

\mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}} (how to create a BVH), \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} (how to destroy a BVH)

\mbox{\hyperlink{a00459_gaf572b7bec28d55bf2c72719742703dff}{Spherical\+Distribute}} to get the direction of every ray casted by this function. Can be useful to determine the point of intersection for every ray casted.
\end{DoxySeeAlso}
\begin{DoxyParagraph}{Example}

\end{DoxyParagraph}
Begin by {\bfseries{loading an .obj file}} (\mbox{\hyperlink{a00455_mesh_setup}{Mesh setup}}).~\newline
 Then, {\bfseries{create a BVH}} (\mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}}) using the {\bfseries{mesh}}.~\newline


Set up the parameters for the view analysis. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Preparing the parameters for SphericalViewAnalysisNoAggregateFlat}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Define point to start ray}}
\DoxyCodeLine{        \textcolor{comment}{// These are Cartesian coordinates.}}
\DoxyCodeLine{        std::array<float, 3> p1 \{ 0.0f, 0.0f, 2.0f \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Define direction to cast ray}}
\DoxyCodeLine{        \textcolor{comment}{// These are vector components, not Cartesian coordinates.}}
\DoxyCodeLine{        std::array<float, 3> dir \{ 0.0f, 0.0f, -\/1.0f \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// This is a container of nodes to be analyzed.}}
\DoxyCodeLine{        \textcolor{comment}{// SphericalViewAnalysisNoAggregateFlat accepts a (Node *) parameter,}}
\DoxyCodeLine{        \textcolor{comment}{// so a raw stack-\/allocated array will suffice.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// This may also be a pointer to a heap-\/allocated buffer}}
\DoxyCodeLine{        \textcolor{comment}{// (which is owned by a vector<Node>, accessed via the vector<Node>::data() method).}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// ...or, it can be a pointer to memory allocated by the caller via operator new[node\_count]}}
\DoxyCodeLine{        \textcolor{comment}{// (if this route is taken, be sure to release the memory with operator delete[] after use)}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{int} node\_count = 1;           \textcolor{comment}{// should be the element count in nodes}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} ray\_count = 1000;               \textcolor{comment}{// will be mutated by SphericalViewAnalysisNoAggregateFlat}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} height = 1.7f;          \textcolor{comment}{// height to offset nodes from the ground, in meters}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} upward\_fov = 50.0f;     \textcolor{comment}{// default parameter is 50.0f in Python code}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{float} downward\_fov = 70.0f;   \textcolor{comment}{// default parameter is 70.0f in Python code}}

\end{DoxyCodeInclude}


Now you must prepare a pointer to a std\+::vector\texorpdfstring{$<$}{<}\mbox{\hyperlink{a02087}{Ray\+Result}}\texorpdfstring{$>$}{>}.~\newline
 View analysis results will be stored at the memory addressed by this pointer. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Declare a pointer to vector<RayResult>, named results.}}
\DoxyCodeLine{        \textcolor{comment}{// This pointer will point to memory on the free store,}}
\DoxyCodeLine{        \textcolor{comment}{// allocated within SphericalViewAnalysisNoAggregateFlat.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// results\_data will point to the underlying buffer within *results,}}
\DoxyCodeLine{        \textcolor{comment}{// which will be assigned inside SphericalViewAnalysisNoAggregateFlat.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Note that we must call operator delete on results when we are finished with it.}}
\DoxyCodeLine{        std::vector<RayResult>* results = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{        \mbox{\hyperlink{a02087}{RayResult}}* results\_data = \textcolor{keyword}{nullptr};}

\end{DoxyCodeInclude}


We are now ready to call \mbox{\hyperlink{a00459_ga348af4492f3e4e7ffab6da3e86de3924}{Spherical\+View\+Analysis\+No\+Aggregate\+Flat}}. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Conducting a view analysis on the node at position p1.}}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00459_ga348af4492f3e4e7ffab6da3e86de3924}{SphericalViewAnalysisNoAggregateFlat}}(bvh,}
\DoxyCodeLine{            p1.data(), node\_count, \&ray\_count,}
\DoxyCodeLine{            upward\_fov, downward\_fov, height,}
\DoxyCodeLine{            \&results, \&results\_data);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at SphericalViewAnalysisNoAggregateFlat, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


We can output the contents of the {\bfseries{results vector}} to {\bfseries{stdout}}. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Print results vector (vector<RayResult>)}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{int} start\_range = 15;}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{int} end\_range = 20;}
\DoxyCodeLine{}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = start\_range; i < end\_range; i++) \{}
\DoxyCodeLine{            \textcolor{keyword}{auto} result = (*results)[i];}
\DoxyCodeLine{}
\DoxyCodeLine{            std::cout << \textcolor{stringliteral}{"{}("{}} << result.distance << \textcolor{stringliteral}{"{}, "{}} << result.meshid << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (i < end\_range -\/ 1) \{}
\DoxyCodeLine{                std::cout << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{            \}}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}]"{}} << std::endl;}

\end{DoxyCodeInclude}


After using the view analysis results, its resources must be {\bfseries{relinquished}}. 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// Memory resource cleanup.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// destroy vector<RayResult>}}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (results) \{}
\DoxyCodeLine{            \textcolor{keyword}{delete} results;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


From here, please review the example at \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} for instructions~\newline
 on how to free the remainder of the resources used for the view analysis --~\newline
 which are the (vector\texorpdfstring{$<$}{<}\mbox{\hyperlink{a01351}{HF\+::\+Geometry\+::\+Mesh\+Info}}\texorpdfstring{$>$}{>} $\ast$) and (\mbox{\hyperlink{}{HF\+::\+Raytracer\+::\+Embree\+Ray\+Tracer}} $\ast$) instances.

{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Load\+OBJ loaded mesh successfully into loaded\+\_\+obj at address 00000293CC9\+C8290, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Create\+Raytracer created Embree\+Ray\+Tracer successfully into bvh at address 00000293C3012\+D20, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} \mbox{[}(-\/1, -\/1), (-\/1, -\/1), (15.\+8334, 0), (-\/1, -\/1), (-\/1, -\/1)\mbox{]}}~\newline


Definition at line \mbox{\hyperlink{a00440_source_l00106}{106}} of file \mbox{\hyperlink{a00440_source}{view\+\_\+analysis\+\_\+\+C.\+cpp}}.



References \mbox{\hyperlink{a00245_source_l00024}{Convert\+Raw\+Float\+Array\+To\+Points()}}, and \mbox{\hyperlink{a00176_source_l00032}{HF\+::\+Exceptions\+::\+OK}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00459_ga348af4492f3e4e7ffab6da3e86de3924_cgraph}
\end{center}
\end{figure}
