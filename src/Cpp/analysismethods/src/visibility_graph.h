///
///	\file		visibility_graph.h
///
///	\brief		Contains definitions for the <see cref = "HF::VisibilityGraph">VisibilityGraph</see> class
///	\author		TBA
///	\date		17 Jun 2020

#include <vector>

// Forward Declares
namespace HF {
	namespace SpatialStructures {
		class Graph;			///< see graph.h in spatialstructures
		struct Node;			///< see node.h in spatialstructures
		struct Edge;			///< see edge.h in spatialstructures
	}

	namespace RayTracer {
		class EmbreeRayTracer;	///< see embree_raytracer.h in raytracer
	}
}


/*!
	\brief Evaluate visibility between points in a set of locations. 

	\details
	A Visibility Graph is a graph of points of space locations that have a clear line of sight to eachother. 

	Edges in Visibility Graph are bidirectional, since if one node can see another node, the inverse is true.
	Generating a Visibility Graph from a set of nodes consists of performing a line of sight check
	between each combination of nodes, and creating an edge if the line of sight check passes.

	\remarks
	One can quickly summarize the information in a Visibility Graph by summarizing the values of its
	edges for each node in the graph. 

	\see HF::SpatialStructures::Graph for more info on the Graph Datatype that is returned from all functions
	in the VisibilityGraph namespace.
*/
namespace HF::VisibilityGraph {
	/// <summary> Generate a Visibility Graph between every node in a set of nodes in parallel. </summary>

	/// <param name="ert"> A Raytracer conatining the geometry to use as obstacles for occlusion checks. </param>
	/// <param name="input_nodes"> X,Y,Z locations of nodes for the Visibility Graph. </param>
	/// <param name="height"> Height to offset nodes in the z-direction before generating the VisibilityGraph.</param>
	/*!
		\returns 
		A VisibilityGraph for generated from every node in input_nodes. The cost of each edge in the graph
		is equal to the distance between both nodes.

		\note 
		After nodes are offset from the ground, a check is performed to determine if it intersects any geometry.
		If offsetting the node causes it to intersect any geometry,then the node will not be considered for connections
		with other nodes and will always have no outgoing or incoming edges. 

		\details
		Every node is offset height meters off the ground, then an occlusion ray is cast between every set of nodes.
		If this occlusion ray does not intersect any geometry then an edge is created between the set of nodes with
		a cost equal to the distance between both nodes. The Graph generated by this algorithm is directed, however
		for each pair of nodes the edge is only stored in the node with the lower ID. This reduces the size of the
		graph in memory by about 50% and reduces the number of checks since every node will only need to check for
		edges with nodes that have a higher ID than itself. 

		\par Parallelism
		Edges are checked on a seperate core for each node. This algorithm will always use every core on a user's
		machine. 

		\par Complexity
		The time complexity of this algorithm is O(n^2), performing approximately (n^2+n)/2 operations gauranteed
		for each execution.	The space complexity matches the time complexity, but the actual space used can be less
		depending on the number	of edges created.

		\see AllToAllUndirected for a version of this algorithm that checks for edges between every node
		in nodes regardless of ID. 
		\see GroupToGroup For an algortithm that only calculates a visibility graph for one set of nodes to another
		set of nodes. 

		\code
			// be sure to #include "objloader.h"

			// path to OBJ file for a flat plane
			std::string plane_path = "plane.obj";

			// Create a vector of MeshInfo from plane_path, using LoadMeshObjects. Note that
			// LoadMeshObjects has two more arguments after plane_path - an enum
			// HF::Geometry::GROUP_METHOD (defaults to GROUP_METHOD::ONLY_FILE) a bool
			// (defaults to true, used to convert OBJ coordinate system to Rhino coordinates)
			std::vector<HF::Geometry::MeshInfo> meshInfo = HF::Geometry::LoadMeshObjects(plane_path);

			// Create an EmbreeRayTracer.
			HF::RayTracer::EmbreeRayTracer tracer(meshInfo);

			std::vector<HF::SpatialStructures::Node> node_vec;		// container of nodes
			const int reserve_count = 100;							// pre-defined reserve size
			node_vec.reserve(reserve_count);						// reserve reserve_count blocks for node_vec

			// Construct reserve_count Node and insert each of them into node_vec
			for (float i = -5.0; i < 5.0; i++) {
				// runs 10 times
				for (float j = -5; j < 5.0; j++) {
					// runs 10 times
					node_vec.emplace_back(Node(i, j, 0.0f));	// all Node ID default to -1
				}
			}

			// AllToAll constructs and returns a Graph consisting of Node (from node_vec)
			// that do not occlude each other
			float desired_height = 2.0f;		// Height of graph
			HF::SpatialStructures::Graph graph = AllToAll(tracer, node_vec, desired_height);
		\endcode
	*/
	HF::SpatialStructures::Graph AllToAll(
		HF::RayTracer::EmbreeRayTracer& ert,
		const std::vector<HF::SpatialStructures::Node>& input_nodes,
		float height = 1.7f
	);

	/// <summary>
	/// Generate a Visibility Graph from a set of nodes to another set of nodes.
	/// </summary>
	/*!

		\param ert  A Raytracer conatining the geometry to use as obstacles for occlusion checks. 
		\param from X,Y,Z locations of nodes to cast rays from.
		\param to X,Y,Z locations of nodes to cast rays to.
		\param Height to offset nodes in the z-direction before generating the VisibilityGraph.

		\returns
		A VisibilityGraph generated from every node in from to every node in to. The cost of each edge in the graph
		is equal to the distance between both nodes.

		\note 
		The ID of nodes in the new graph wil correspond to the node's location in the from or to arrays.
		First every node in from will in from be placed in order, then every node in to will be placed in order. 
		This means that the ID of every node in from will be equal to its index in from, and the ID of every
		node in to will be equal to the number of nodes in from plus its index in to. 

		\details
		The algorithm used here is similar to that of VisibilityGraph::AllToAll, however edges are cast from 
		every node in from to every node in to. All nodes in to will have no outgoing edges. 

		\remarks 
		This can be useful for generating the visibility graph for a subset of nodes, such as the visibility from
		a building to the outside, without needing to calculate the visibility from every node to every other node.

		\par Parallelism
		Edges are checked on a seperate core for each node. This algorithm will always use every core on a user's
		machine.

		\par Complexity
		In time: O(ft) where f is the number of nodes in from, and t is the number of nodes in to. In space,
		O(ft) as well.
	

		\code
			// be sure to #include "objloader.h"

			// path to OBJ file for a flat plane
			std::string plane_path = "plane.obj";

			// Create a vector of MeshInfo from plane_path, using LoadMeshObjects. Note that
			// LoadMeshObjects has two more arguments after plane_path - an enum
			// HF::Geometry::GROUP_METHOD (defaults to GROUP_METHOD::ONLY_FILE) a bool
			// (defaults to true, used to convert OBJ coordinate system to Rhino coordinates)
			std::vector<HF::Geometry::MeshInfo> meshInfo = HF::Geometry::LoadMeshObjects(plane_path);

			// Create an EmbreeRayTracer.
			HF::RayTracer::EmbreeRayTracer tracer(meshInfo);

			std::vector<HF::SpatialStructures::Node> node_vec_0;		// First container of Node
			std::vector<HF::SpatialStructures::Node> node_vec_1;		// Second container of Node

			const int reserve_count = 100;		// Pre-defined reserve size
			node_vec_0.reserve(reserve_count);	// Reserve reserve_count blocks for both vectors
			node_vec_1.reserve(reserve_count);

			// 0) Construct reserve_count Node and insert each of them into node_vec_0
			for (float i = -5.0; i < 5.0; i++) {
				// runs 10 times
				for (float j = -5.0; j < 5.0; j++) {
					// runs 10 times
					node_vec_0.emplace_back(HF::SpatialStructures::Node(i, j, 0.0f));	// all Node ID default to -1
				}
			}

			// 1) Construct reserve_count Node and insert each of them into node_vec_1
			for (float i = 0.0; i < 10.0; i++) {
				for (float j = 0.0; j < 10.0; j++) {
					node_vec_1.emplace_back(HF::SpatialStructures::Node(i, j, 0.0f));	// all Node ID default to -1
				}
			}

			// GroupToGroup constructs and returns a Graph consisting of Node (between
			// node_vec_0 and node_vec_1) such that the nodes do not occlude each other
			float desired_height = 2.0f;		// Height of graph
			HF::SpatialStructures::Graph graph = HF::VisibilityGraph::GroupToGroup(tracer, node_vec_0, node_vec_1, desired_height);
		\endcode
	*/
	HF::SpatialStructures::Graph GroupToGroup(
		HF::RayTracer::EmbreeRayTracer& ert,
		const std::vector<HF::SpatialStructures::Node>& from,
		const std::vector<HF::SpatialStructures::Node>& to,
		float height = 1.7f
	);

	/// <summary> Generate a Visibility Graph with every edge stored twice. </summary>
	/*!

		\param ert  A Raytracer conatining the geometry to use as obstacles for occlusion checks.
		\param from X,Y,Z locations of nodes to create the visibility graph from.
		\param Height to offset nodes in the z-direction before generating the VisibilityGraph.
		\param cores number of cores to use for parallel processing. -1 will use all available cores.

		\returns
		A VisibilityGraph generated from every node in input_nodes. The cost of each edge in the graph
		is equal to the distance between both nodes.

		\details
		Similar to VisibilityGraph::AllToAll, however every edge is stored in both nodes that it connects.
		For example, An edge betwee node 1 and node 2 would only be stored in node 1 in AllToAll, however here
		the edge would exist in both node1, and node2, in this algorithm.

		\remarks
		In most cases it's preferred to use VisibilityGraph::AllToAll since it saves a lot of time and space,
		however it may be advantageous to have edges stored in both nodes for certain applications. 

		\par Parallelism
		Edges are checked on a seperate core for each node. This algorithm will use every core on a user's
		machine if cores is set to -1. Otherwise it will use the number of cores specified in cores.

		\par complexity
		O(n^2) in space and time.  

		\code
			// be sure to #include "objloader.h"

			// path to OBJ file for a flat plane
			std::string plane_path = "plane.obj";

			// Create a vector of MeshInfo from plane_path, using LoadMeshObjects. Note that
			// LoadMeshObjects has two more arguments after plane_path - an enum
			// HF::Geometry::GROUP_METHOD (defaults to GROUP_METHOD::ONLY_FILE) a bool
			// (defaults to true, used to convert OBJ coordinate system to Rhino coordinates)
			std::vector<HF::Geometry::MeshInfo> meshInfo = HF::Geometry::LoadMeshObjects(plane_path);

			// Create an EmbreeRayTracer.
			HF::RayTracer::EmbreeRayTracer tracer(meshInfo);

			std::vector<HF::SpatialStructures::Node> node_vec;		// container of nodes
			const int reserve_count = 100;							// pre-defined reserve size
			node_vec.reserve(reserve_count);						// reserve reserve_count blocks for node_vec

			// Construct reserve_count Node and insert each of them into node_vec
			for (float i = -5.0; i < 5.0; i++) {
				// runs 10 times
				for (float j = -5; j < 5.0; j++) {
					// runs 10 times
					node_vec.emplace_back(HF::SpatialStructures::Node(i, j, 0.0f));	// all Node ID default to -1
				}
			}

			// AllToAllUndirected constructs and returns a Graph consisting of Node (from
			// node_vec) that do not occlude each other
			float desired_height = 2.0f;		// Height of graph
			int core_count = 4;					// For omp_set_num_threads(int num_threads), CPU core count
			HF::SpatialStructures::Graph graph =
				HF::VisibilityGraph::AllToAllUndirected(tracer, node_vec, desired_height, core_count);
		\endcode
	*/
	HF::SpatialStructures::Graph AllToAllUndirected(
		HF::RayTracer::EmbreeRayTracer& ert,
		const std::vector<HF::SpatialStructures::Node>& nodes,
		float height,
		int cores = -1
	);
}
