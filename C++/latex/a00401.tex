\hypertarget{a00401}{}\doxysection{HF\+::Visibility\+Graph Namespace Reference}
\label{a00401}\index{HF::VisibilityGraph@{HF::VisibilityGraph}}


Evaluate visibility between points in a set of locations.  


\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{a00401_af811d21e4c49275521912df9254bb737}{Height\+Check}} (const \mbox{\hyperlink{a02005}{Node}} \&\mbox{\hyperlink{a02005}{Node}}, float height, \mbox{\hyperlink{a01345}{Embree\+Ray\+Tracer}} \&ert)
\begin{DoxyCompactList}\small\item\em Check if Node can be raised by height without clipping into any geometry. \end{DoxyCompactList}\item 
vector$<$ int $>$ \mbox{\hyperlink{a00401_a05b8a83ab27113369c95649470d864b9}{Height\+Check\+All\+Nodes}} (const vector$<$ \mbox{\hyperlink{a02005}{Node}} $>$ \&nodes\+\_\+to\+\_\+filter, float height, \mbox{\hyperlink{a01345}{Embree\+Ray\+Tracer}} \&ert)
\begin{DoxyCompactList}\small\item\em Obtain the indexes of all nodes that pass the Height\+Check. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{a00401_a4d9cf77879eb78075f7f7b0a7e31119a}{Is\+Occlusion\+Between}} (const \mbox{\hyperlink{a02005}{Node}} \&node\+\_\+a, const \mbox{\hyperlink{a02005}{Node}} \&node\+\_\+b, \mbox{\hyperlink{a01345}{Embree\+Ray\+Tracer}} \&ert, float height=1.\+7f, float pre\+\_\+calculated\+\_\+distance=0.\+0f)
\begin{DoxyCompactList}\small\item\em Perform a line of sight check between two nodes. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a01485}{Graph}} \mbox{\hyperlink{a00401_a12eb1e4c06400c4625cd22d925927b03}{All\+To\+All}} (\mbox{\hyperlink{a01345}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} \&ert, const std\+::vector$<$ \mbox{\hyperlink{a02005}{HF\+::\+Spatial\+Structures\+::\+Node}} $>$ \&input\+\_\+nodes, float height=1.\+7f)
\begin{DoxyCompactList}\small\item\em Generate a Visibility Graph between every node in a set of nodes in parallel.  \end{DoxyCompactList}\item 
\mbox{\hyperlink{a01485}{Graph}} \mbox{\hyperlink{a00401_ae42a5aafdfcc29b6a668355c07602efb}{Group\+To\+Group}} (\mbox{\hyperlink{a01345}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} \&ert, const std\+::vector$<$ \mbox{\hyperlink{a02005}{HF\+::\+Spatial\+Structures\+::\+Node}} $>$ \&from, const std\+::vector$<$ \mbox{\hyperlink{a02005}{HF\+::\+Spatial\+Structures\+::\+Node}} $>$ \&to, float height=1.\+7f)
\begin{DoxyCompactList}\small\item\em Generate a Visibility Graph from a set of nodes to another set of nodes.  \end{DoxyCompactList}\item 
\mbox{\hyperlink{a01485}{Graph}} \mbox{\hyperlink{a00401_ab1db87927118f70786a664c3b3cc7905}{All\+To\+All\+Undirected}} (\mbox{\hyperlink{a01345}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} \&ert, const std\+::vector$<$ \mbox{\hyperlink{a02005}{HF\+::\+Spatial\+Structures\+::\+Node}} $>$ \&nodes, float height, int cores=-\/1)
\begin{DoxyCompactList}\small\item\em Generate a Visibility Graph with every edge stored twice.  \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Evaluate visibility between points in a set of locations. 

A Visibility Graph is a graph of points of space locations that have a clear line of sight to eachother.

Edges in Visibility Graph are bidirectional, since if one node can see another node, the inverse is true. Generating a Visibility Graph from a set of nodes consists of performing a line of sight check between each combination of nodes, and creating an edge if the line of sight check passes.

\begin{DoxyRemark}{Remarks}
One can quickly summarize the information in a Visibility Graph by summarizing the values of its edges for each node in the graph.
\end{DoxyRemark}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a01485}{HF\+::\+Spatial\+Structures\+::\+Graph}} for more info on the Graph Datatype that is returned from all functions in the \mbox{\hyperlink{a00401}{Visibility\+Graph}} namespace. 
\end{DoxySeeAlso}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{a00401_a12eb1e4c06400c4625cd22d925927b03}\label{a00401_a12eb1e4c06400c4625cd22d925927b03}} 
\index{HF::VisibilityGraph@{HF::VisibilityGraph}!AllToAll@{AllToAll}}
\index{AllToAll@{AllToAll}!HF::VisibilityGraph@{HF::VisibilityGraph}}
\doxysubsubsection{\texorpdfstring{AllToAll()}{AllToAll()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a01485}{HF\+::\+Spatial\+Structures\+::\+Graph}} HF\+::\+Visibility\+Graph\+::\+All\+To\+All (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01345}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} \&}]{ert,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{a02005}{HF\+::\+Spatial\+Structures\+::\+Node}} $>$ \&}]{input\+\_\+nodes,  }\item[{float}]{height = {\ttfamily 1.7f} }\end{DoxyParamCaption})}



Generate a Visibility Graph between every node in a set of nodes in parallel.  


\begin{DoxyParams}{Parameters}
{\em ert} & A Raytracer conatining the geometry to use as obstacles for occlusion checks. \\
\hline
{\em input\+\_\+nodes} & X,Y,Z locations of nodes for the Visibility Graph. \\
\hline
{\em height} & Height to offset nodes in the z-\/direction before generating the \mbox{\hyperlink{a00401}{Visibility\+Graph}}.\\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{a00401}{Visibility\+Graph}} for generated from every node in input\+\_\+nodes. The cost of each edge in the graph is equal to the distance between both nodes.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
After nodes are offset from the ground, a check is performed to determine if it intersects any geometry. If offsetting the node causes it to intersect any geometry,then the node will not be considered for connections with other nodes and will always have no outgoing or incoming edges.
\end{DoxyNote}
Every node is offset height meters off the ground, then an occlusion ray is cast between every set of nodes. If this occlusion ray does not intersect any geometry then an edge is created between the set of nodes with a cost equal to the distance between both nodes. The Graph generated by this algorithm is directed, however for each pair of nodes the edge is only stored in the node with the lower ID. This reduces the size of the graph in memory by about 50\% and reduces the number of checks since every node will only need to check for edges with nodes that have a higher ID than itself.

\begin{DoxyParagraph}{Parallelism}
Edges are checked on a seperate core for each node. This algorithm will always use every core on a user\textquotesingle{}s machine.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Complexity}
The time complexity of this algorithm is O(n$^\wedge$2), performing approximately (n$^\wedge$2+n)/2 operations gauranteed for each execution. The space complexity matches the time complexity, but the actual space used can be less depending on the number of edges created.
\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00401_ab1db87927118f70786a664c3b3cc7905}{All\+To\+All\+Undirected}} for a version of this algorithm that checks for edges between every node in nodes regardless of ID. 

\mbox{\hyperlink{a00401_ae42a5aafdfcc29b6a668355c07602efb}{Group\+To\+Group}} For an algortithm that only calculates a visibility graph for one set of nodes to another set of nodes.
\end{DoxySeeAlso}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// be sure to \#include "{}objloader.h"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// path to OBJ file for a flat plane}}
\DoxyCodeLine{std::string plane\_path = \textcolor{stringliteral}{"{}plane.obj"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a vector of MeshInfo from plane\_path, using LoadMeshObjects. Note that}}
\DoxyCodeLine{\textcolor{comment}{// LoadMeshObjects has two more arguments after plane\_path -\/ an enum}}
\DoxyCodeLine{\textcolor{comment}{// HF::Geometry::GROUP\_METHOD (defaults to GROUP\_METHOD::ONLY\_FILE) a bool}}
\DoxyCodeLine{\textcolor{comment}{// (defaults to true, used to convert OBJ coordinate system to Rhino coordinates)}}
\DoxyCodeLine{std::vector<HF::Geometry::MeshInfo> meshInfo = \mbox{\hyperlink{a00403_a06c0c11adb62f8b204e42f75ac1990ac}{HF::Geometry::LoadMeshObjects}}(plane\_path);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create an EmbreeRayTracer.}}
\DoxyCodeLine{\mbox{\hyperlink{a01345}{HF::RayTracer::EmbreeRayTracer}} tracer(meshInfo);}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<HF::SpatialStructures::Node> node\_vec;      \textcolor{comment}{// container of nodes}}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} reserve\_count = 100;                          \textcolor{comment}{// pre-\/defined reserve size}}
\DoxyCodeLine{node\_vec.reserve(reserve\_count);                        \textcolor{comment}{// reserve reserve\_count blocks for node\_vec}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Construct reserve\_count Node and insert each of them into node\_vec}}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} i = -\/5.0; i < 5.0; i++) \{}
\DoxyCodeLine{    \textcolor{comment}{// runs 10 times}}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} j = -\/5; j < 5.0; j++) \{}
\DoxyCodeLine{        \textcolor{comment}{// runs 10 times}}
\DoxyCodeLine{        node\_vec.emplace\_back(Node(i, j, 0.0f));    \textcolor{comment}{// all Node ID default to -\/1}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// AllToAll constructs and returns a Graph consisting of Node (from node\_vec)}}
\DoxyCodeLine{\textcolor{comment}{// that do not occlude each other}}
\DoxyCodeLine{\textcolor{keywordtype}{float} desired\_height = 2.0f;        \textcolor{comment}{// Height of graph}}
\DoxyCodeLine{\mbox{\hyperlink{a01485}{HF::SpatialStructures::Graph}} graph = \mbox{\hyperlink{a00401_a12eb1e4c06400c4625cd22d925927b03}{AllToAll}}(tracer, node\_vec, desired\_height);}

\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{a00026_source_l00128}{128}} of file \mbox{\hyperlink{a00026_source}{visibility\+\_\+graph.\+cpp}}.



References \mbox{\hyperlink{a03488_source_l00040}{HF\+::\+Spatial\+Structures\+::\+Node\+::distance\+To()}}, \mbox{\hyperlink{a00026_source_l00069}{Height\+Check\+All\+Nodes()}}, \mbox{\hyperlink{a00026_source_l00103}{Is\+Occlusion\+Between()}}, and \mbox{\hyperlink{a01485_a2710af2a75976862d7a235793567d2f3}{HF\+::\+Spatial\+Structures\+::\+Graph\+::size()}}.



Referenced by \mbox{\hyperlink{a00380_source_l00016}{Create\+Visibility\+Graph\+All\+To\+All()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00401_a12eb1e4c06400c4625cd22d925927b03_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=333pt]{a00401_a12eb1e4c06400c4625cd22d925927b03_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00401_ab1db87927118f70786a664c3b3cc7905}\label{a00401_ab1db87927118f70786a664c3b3cc7905}} 
\index{HF::VisibilityGraph@{HF::VisibilityGraph}!AllToAllUndirected@{AllToAllUndirected}}
\index{AllToAllUndirected@{AllToAllUndirected}!HF::VisibilityGraph@{HF::VisibilityGraph}}
\doxysubsubsection{\texorpdfstring{AllToAllUndirected()}{AllToAllUndirected()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a01485}{HF\+::\+Spatial\+Structures\+::\+Graph}} HF\+::\+Visibility\+Graph\+::\+All\+To\+All\+Undirected (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01345}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} \&}]{ert,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{a02005}{HF\+::\+Spatial\+Structures\+::\+Node}} $>$ \&}]{nodes,  }\item[{float}]{height,  }\item[{int}]{cores = {\ttfamily -\/1} }\end{DoxyParamCaption})}



Generate a Visibility Graph with every edge stored twice.  


\begin{DoxyParams}{Parameters}
{\em ert} & A Raytracer conatining the geometry to use as obstacles for occlusion checks. \\
\hline
{\em from} & X,Y,Z locations of nodes to create the visibility graph from. \\
\hline
{\em Height} & to offset nodes in the z-\/direction before generating the \mbox{\hyperlink{a00401}{Visibility\+Graph}}. \\
\hline
{\em cores} & number of cores to use for parallel processing. -\/1 will use all available cores.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{a00401}{Visibility\+Graph}} generated from every node in input\+\_\+nodes. The cost of each edge in the graph is equal to the distance between both nodes.
\end{DoxyReturn}
Similar to \mbox{\hyperlink{a00401_a12eb1e4c06400c4625cd22d925927b03}{Visibility\+Graph\+::\+All\+To\+All}}, however every edge is stored in both nodes that it connects. For example, An edge betwee node 1 and node 2 would only be stored in node 1 in All\+To\+All, however here the edge would exist in both node1, and node2, in this algorithm.

\begin{DoxyRemark}{Remarks}
In most cases it\textquotesingle{}s preferred to use \mbox{\hyperlink{a00401_a12eb1e4c06400c4625cd22d925927b03}{Visibility\+Graph\+::\+All\+To\+All}} since it saves a lot of time and space, however it may be advantageous to have edges stored in both nodes for certain applications.
\end{DoxyRemark}
\begin{DoxyParagraph}{Parallelism}
Edges are checked on a seperate core for each node. This algorithm will use every core on a user\textquotesingle{}s machine if cores is set to -\/1. Otherwise it will use the number of cores specified in cores.
\end{DoxyParagraph}
\begin{DoxyParagraph}{complexity}
O(n$^\wedge$2) in space and time. ~\newline

\end{DoxyParagraph}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// be sure to \#include "{}objloader.h"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// path to OBJ file for a flat plane}}
\DoxyCodeLine{std::string plane\_path = \textcolor{stringliteral}{"{}plane.obj"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a vector of MeshInfo from plane\_path, using LoadMeshObjects. Note that}}
\DoxyCodeLine{\textcolor{comment}{// LoadMeshObjects has two more arguments after plane\_path -\/ an enum}}
\DoxyCodeLine{\textcolor{comment}{// HF::Geometry::GROUP\_METHOD (defaults to GROUP\_METHOD::ONLY\_FILE) a bool}}
\DoxyCodeLine{\textcolor{comment}{// (defaults to true, used to convert OBJ coordinate system to Rhino coordinates)}}
\DoxyCodeLine{std::vector<HF::Geometry::MeshInfo> meshInfo = \mbox{\hyperlink{a00403_a06c0c11adb62f8b204e42f75ac1990ac}{HF::Geometry::LoadMeshObjects}}(plane\_path);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create an EmbreeRayTracer.}}
\DoxyCodeLine{\mbox{\hyperlink{a01345}{HF::RayTracer::EmbreeRayTracer}} tracer(meshInfo);}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<HF::SpatialStructures::Node> node\_vec;      \textcolor{comment}{// container of nodes}}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} reserve\_count = 100;                          \textcolor{comment}{// pre-\/defined reserve size}}
\DoxyCodeLine{node\_vec.reserve(reserve\_count);                        \textcolor{comment}{// reserve reserve\_count blocks for node\_vec}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Construct reserve\_count Node and insert each of them into node\_vec}}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} i = -\/5.0; i < 5.0; i++) \{}
\DoxyCodeLine{    \textcolor{comment}{// runs 10 times}}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} j = -\/5; j < 5.0; j++) \{}
\DoxyCodeLine{        \textcolor{comment}{// runs 10 times}}
\DoxyCodeLine{        node\_vec.emplace\_back(\mbox{\hyperlink{a02005}{HF::SpatialStructures::Node}}(i, j, 0.0f)); \textcolor{comment}{// all Node ID default to -\/1}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// AllToAllUndirected constructs and returns a Graph consisting of Node (from}}
\DoxyCodeLine{\textcolor{comment}{// node\_vec) that do not occlude each other}}
\DoxyCodeLine{\textcolor{keywordtype}{float} desired\_height = 2.0f;        \textcolor{comment}{// Height of graph}}
\DoxyCodeLine{\textcolor{keywordtype}{int} core\_count = 4;                 \textcolor{comment}{// For omp\_set\_num\_threads(int num\_threads), CPU core count}}
\DoxyCodeLine{\mbox{\hyperlink{a01485}{HF::SpatialStructures::Graph}} graph =}
\DoxyCodeLine{    \mbox{\hyperlink{a00401_ab1db87927118f70786a664c3b3cc7905}{HF::VisibilityGraph::AllToAllUndirected}}(tracer, node\_vec, desired\_height, core\_count);}

\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{a00026_source_l00252}{252}} of file \mbox{\hyperlink{a00026_source}{visibility\+\_\+graph.\+cpp}}.



References \mbox{\hyperlink{a03488_source_l00040}{HF\+::\+Spatial\+Structures\+::\+Node\+::distance\+To()}}, \mbox{\hyperlink{a00026_source_l00069}{Height\+Check\+All\+Nodes()}}, \mbox{\hyperlink{a00026_source_l00103}{Is\+Occlusion\+Between()}}, and \mbox{\hyperlink{a01485_a2710af2a75976862d7a235793567d2f3}{HF\+::\+Spatial\+Structures\+::\+Graph\+::size()}}.



Referenced by \mbox{\hyperlink{a00380_source_l00040}{Create\+Visibility\+Graph\+All\+To\+All\+Undirected()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00401_ab1db87927118f70786a664c3b3cc7905_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=336pt]{a00401_ab1db87927118f70786a664c3b3cc7905_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00401_ae42a5aafdfcc29b6a668355c07602efb}\label{a00401_ae42a5aafdfcc29b6a668355c07602efb}} 
\index{HF::VisibilityGraph@{HF::VisibilityGraph}!GroupToGroup@{GroupToGroup}}
\index{GroupToGroup@{GroupToGroup}!HF::VisibilityGraph@{HF::VisibilityGraph}}
\doxysubsubsection{\texorpdfstring{GroupToGroup()}{GroupToGroup()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a01485}{HF\+::\+Spatial\+Structures\+::\+Graph}} HF\+::\+Visibility\+Graph\+::\+Group\+To\+Group (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01345}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} \&}]{ert,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{a02005}{HF\+::\+Spatial\+Structures\+::\+Node}} $>$ \&}]{from,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{a02005}{HF\+::\+Spatial\+Structures\+::\+Node}} $>$ \&}]{to,  }\item[{float}]{height = {\ttfamily 1.7f} }\end{DoxyParamCaption})}



Generate a Visibility Graph from a set of nodes to another set of nodes.  


\begin{DoxyParams}{Parameters}
{\em ert} & A Raytracer conatining the geometry to use as obstacles for occlusion checks. \\
\hline
{\em from} & X,Y,Z locations of nodes to cast rays from. \\
\hline
{\em to} & X,Y,Z locations of nodes to cast rays to. \\
\hline
{\em Height} & to offset nodes in the z-\/direction before generating the \mbox{\hyperlink{a00401}{Visibility\+Graph}}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{a00401}{Visibility\+Graph}} generated from every node in from to every node in to. The cost of each edge in the graph is equal to the distance between both nodes.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The ID of nodes in the new graph wil correspond to the node\textquotesingle{}s location in the from or to arrays. First every node in from will in from be placed in order, then every node in to will be placed in order. This means that the ID of every node in from will be equal to its index in from, and the ID of every node in to will be equal to the number of nodes in from plus its index in to.
\end{DoxyNote}
The algorithm used here is similar to that of \mbox{\hyperlink{a00401_a12eb1e4c06400c4625cd22d925927b03}{Visibility\+Graph\+::\+All\+To\+All}}, however edges are cast from every node in from to every node in to. All nodes in to will have no outgoing edges.

\begin{DoxyRemark}{Remarks}
This can be useful for generating the visibility graph for a subset of nodes, such as the visibility from a building to the outside, without needing to calculate the visibility from every node to every other node.
\end{DoxyRemark}
\begin{DoxyParagraph}{Parallelism}
Edges are checked on a seperate core for each node. This algorithm will always use every core on a user\textquotesingle{}s machine.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Complexity}
In time\+: O(ft) where f is the number of nodes in from, and t is the number of nodes in to. In space, O(ft) as well.
\end{DoxyParagraph}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// be sure to \#include "{}objloader.h"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// path to OBJ file for a flat plane}}
\DoxyCodeLine{std::string plane\_path = \textcolor{stringliteral}{"{}plane.obj"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a vector of MeshInfo from plane\_path, using LoadMeshObjects. Note that}}
\DoxyCodeLine{\textcolor{comment}{// LoadMeshObjects has two more arguments after plane\_path -\/ an enum}}
\DoxyCodeLine{\textcolor{comment}{// HF::Geometry::GROUP\_METHOD (defaults to GROUP\_METHOD::ONLY\_FILE) a bool}}
\DoxyCodeLine{\textcolor{comment}{// (defaults to true, used to convert OBJ coordinate system to Rhino coordinates)}}
\DoxyCodeLine{std::vector<HF::Geometry::MeshInfo> meshInfo = \mbox{\hyperlink{a00403_a06c0c11adb62f8b204e42f75ac1990ac}{HF::Geometry::LoadMeshObjects}}(plane\_path);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create an EmbreeRayTracer.}}
\DoxyCodeLine{\mbox{\hyperlink{a01345}{HF::RayTracer::EmbreeRayTracer}} tracer(meshInfo);}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<HF::SpatialStructures::Node> node\_vec\_0;        \textcolor{comment}{// First container of Node}}
\DoxyCodeLine{std::vector<HF::SpatialStructures::Node> node\_vec\_1;        \textcolor{comment}{// Second container of Node}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} reserve\_count = 100;      \textcolor{comment}{// Pre-\/defined reserve size}}
\DoxyCodeLine{node\_vec\_0.reserve(reserve\_count);  \textcolor{comment}{// Reserve reserve\_count blocks for both vectors}}
\DoxyCodeLine{node\_vec\_1.reserve(reserve\_count);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// 0) Construct reserve\_count Node and insert each of them into node\_vec\_0}}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} i = -\/5.0; i < 5.0; i++) \{}
\DoxyCodeLine{    \textcolor{comment}{// runs 10 times}}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} j = -\/5.0; j < 5.0; j++) \{}
\DoxyCodeLine{        \textcolor{comment}{// runs 10 times}}
\DoxyCodeLine{        node\_vec\_0.emplace\_back(\mbox{\hyperlink{a02005}{HF::SpatialStructures::Node}}(i, j, 0.0f));   \textcolor{comment}{// all Node ID default to -\/1}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// 1) Construct reserve\_count Node and insert each of them into node\_vec\_1}}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} i = 0.0; i < 10.0; i++) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} j = 0.0; j < 10.0; j++) \{}
\DoxyCodeLine{        node\_vec\_1.emplace\_back(\mbox{\hyperlink{a02005}{HF::SpatialStructures::Node}}(i, j, 0.0f));   \textcolor{comment}{// all Node ID default to -\/1}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// GroupToGroup constructs and returns a Graph consisting of Node (between}}
\DoxyCodeLine{\textcolor{comment}{// node\_vec\_0 and node\_vec\_1) such that the nodes do not occlude each other}}
\DoxyCodeLine{\textcolor{keywordtype}{float} desired\_height = 2.0f;        \textcolor{comment}{// Height of graph}}
\DoxyCodeLine{\mbox{\hyperlink{a01485}{HF::SpatialStructures::Graph}} graph = \mbox{\hyperlink{a00401_ae42a5aafdfcc29b6a668355c07602efb}{HF::VisibilityGraph::GroupToGroup}}(tracer, node\_vec\_0, node\_vec\_1, desired\_height);}

\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{a00026_source_l00189}{189}} of file \mbox{\hyperlink{a00026_source}{visibility\+\_\+graph.\+cpp}}.



References \mbox{\hyperlink{a03488_source_l00040}{HF\+::\+Spatial\+Structures\+::\+Node\+::distance\+To()}}, \mbox{\hyperlink{a00026_source_l00069}{Height\+Check\+All\+Nodes()}}, \mbox{\hyperlink{a00026_source_l00103}{Is\+Occlusion\+Between()}}, and \mbox{\hyperlink{a01485_a2710af2a75976862d7a235793567d2f3}{HF\+::\+Spatial\+Structures\+::\+Graph\+::size()}}.



Referenced by \mbox{\hyperlink{a00380_source_l00064}{Create\+Visibility\+Graph\+Group\+To\+Group()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00401_ae42a5aafdfcc29b6a668355c07602efb_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{a00401_ae42a5aafdfcc29b6a668355c07602efb_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00401_af811d21e4c49275521912df9254bb737}\label{a00401_af811d21e4c49275521912df9254bb737}} 
\index{HF::VisibilityGraph@{HF::VisibilityGraph}!HeightCheck@{HeightCheck}}
\index{HeightCheck@{HeightCheck}!HF::VisibilityGraph@{HF::VisibilityGraph}}
\doxysubsubsection{\texorpdfstring{HeightCheck()}{HeightCheck()}}
{\footnotesize\ttfamily bool HF\+::\+Visibility\+Graph\+::\+Height\+Check (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a02005}{Node}} \&}]{Node,  }\item[{float}]{height,  }\item[{\mbox{\hyperlink{a01345}{Embree\+Ray\+Tracer}} \&}]{ert }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Check if Node can be raised by height without clipping into any geometry. 


\begin{DoxyParams}{Parameters}
{\em Node} & Node to perform height check on. \\
\hline
{\em height} & Distance to check above the node in meters. Default = 1.\+7m. \\
\hline
{\em ert} & Raytracer containing geometry to intersect with.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if Node can be raised by height without intersecting with any geometry. False otherwise.
\end{DoxyReturn}
Cast an occlusion ray straight up with a distance of height to determine if it will intersect with any geometry.

\begin{DoxyRemark}{Remarks}
This is useful to prevent nodes from going through ceilings or other geometry when comparing the scores of all nodes in a model. 
\end{DoxyRemark}


Definition at line \mbox{\hyperlink{a00026_source_l00047}{47}} of file \mbox{\hyperlink{a00026_source}{visibility\+\_\+graph.\+cpp}}.



References \mbox{\hyperlink{a00146_source_l01186}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer\+::\+Occluded()}}, and \mbox{\hyperlink{a00185_source_l00030}{HF\+::\+Spatial\+Structures\+::\+ROUNDING\+\_\+\+PRECISION}}.



Referenced by \mbox{\hyperlink{a00026_source_l00069}{Height\+Check\+All\+Nodes()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00401_af811d21e4c49275521912df9254bb737_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00401_af811d21e4c49275521912df9254bb737_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00401_a05b8a83ab27113369c95649470d864b9}\label{a00401_a05b8a83ab27113369c95649470d864b9}} 
\index{HF::VisibilityGraph@{HF::VisibilityGraph}!HeightCheckAllNodes@{HeightCheckAllNodes}}
\index{HeightCheckAllNodes@{HeightCheckAllNodes}!HF::VisibilityGraph@{HF::VisibilityGraph}}
\doxysubsubsection{\texorpdfstring{HeightCheckAllNodes()}{HeightCheckAllNodes()}}
{\footnotesize\ttfamily vector$<$ int $>$ HF\+::\+Visibility\+Graph\+::\+Height\+Check\+All\+Nodes (\begin{DoxyParamCaption}\item[{const vector$<$ \mbox{\hyperlink{a02005}{Node}} $>$ \&}]{nodes\+\_\+to\+\_\+filter,  }\item[{float}]{height,  }\item[{\mbox{\hyperlink{a01345}{Embree\+Ray\+Tracer}} \&}]{ert }\end{DoxyParamCaption})}



Obtain the indexes of all nodes that pass the Height\+Check. 


\begin{DoxyParams}{Parameters}
{\em nodes\+\_\+to\+\_\+filter} & Nodes to perform the height check on \\
\hline
{\em height} & Height to check above the nodes \\
\hline
{\em ert} & Raytracer containing the geometry to use as obstacles\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The indexes in nodes\+\_\+to\+\_\+filter of all nodes that pass the height check.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00401_af811d21e4c49275521912df9254bb737}{Height\+Check}} 
\end{DoxySeeAlso}


Definition at line \mbox{\hyperlink{a00026_source_l00069}{69}} of file \mbox{\hyperlink{a00026_source}{visibility\+\_\+graph.\+cpp}}.



References \mbox{\hyperlink{a00026_source_l00047}{Height\+Check()}}.



Referenced by \mbox{\hyperlink{a00026_source_l00128}{All\+To\+All()}}, \mbox{\hyperlink{a00026_source_l00252}{All\+To\+All\+Undirected()}}, and \mbox{\hyperlink{a00026_source_l00189}{Group\+To\+Group()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00401_a05b8a83ab27113369c95649470d864b9_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00401_a05b8a83ab27113369c95649470d864b9_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{a00401_a4d9cf77879eb78075f7f7b0a7e31119a}\label{a00401_a4d9cf77879eb78075f7f7b0a7e31119a}} 
\index{HF::VisibilityGraph@{HF::VisibilityGraph}!IsOcclusionBetween@{IsOcclusionBetween}}
\index{IsOcclusionBetween@{IsOcclusionBetween}!HF::VisibilityGraph@{HF::VisibilityGraph}}
\doxysubsubsection{\texorpdfstring{IsOcclusionBetween()}{IsOcclusionBetween()}}
{\footnotesize\ttfamily bool HF\+::\+Visibility\+Graph\+::\+Is\+Occlusion\+Between (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a02005}{Node}} \&}]{node\+\_\+a,  }\item[{const \mbox{\hyperlink{a02005}{Node}} \&}]{node\+\_\+b,  }\item[{\mbox{\hyperlink{a01345}{Embree\+Ray\+Tracer}} \&}]{ert,  }\item[{float}]{height = {\ttfamily 1.7f},  }\item[{float}]{pre\+\_\+calculated\+\_\+distance = {\ttfamily 0.0f} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Perform a line of sight check between two nodes. 


\begin{DoxyParams}{Parameters}
{\em node\+\_\+a} & Node to check occlusion from. \\
\hline
{\em node\+\_\+b} & Node to check occlusion to. \\
\hline
{\em ert} & Raytracer containing the geometry to use as obstacles. \\
\hline
{\em height} & Distance to offset a node in the z-\/direction before performing the check. \\
\hline
{\em pre\+\_\+calculated\+\_\+distance} & Distance from node\+\_\+a to node\+\_\+b. If set to zero then this will be calculated automatically.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if there is an obstacle blocking line of sight between node\+\_\+a and node\+\_\+b when raised to height.
\end{DoxyReturn}
Calculate the distance between node\+\_\+a and node\+\_\+b if required, then calculate the direction between them. Cast an occlusion ray in the direction between node\+\_\+a and node\+\_\+b with a maximum distance equal to the distance between them. If the ray intersects anything then the nodes don\textquotesingle{}t have a line of sight. 

Definition at line \mbox{\hyperlink{a00026_source_l00103}{103}} of file \mbox{\hyperlink{a00026_source}{visibility\+\_\+graph.\+cpp}}.



References \mbox{\hyperlink{a03488_source_l00131}{HF\+::\+Spatial\+Structures\+::\+Node\+::direction\+To()}}, \mbox{\hyperlink{a03488_source_l00040}{HF\+::\+Spatial\+Structures\+::\+Node\+::distance\+To()}}, and \mbox{\hyperlink{a00146_source_l01186}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer\+::\+Occluded()}}.



Referenced by \mbox{\hyperlink{a00026_source_l00128}{All\+To\+All()}}, \mbox{\hyperlink{a00026_source_l00252}{All\+To\+All\+Undirected()}}, and \mbox{\hyperlink{a00026_source_l00189}{Group\+To\+Group()}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00401_a4d9cf77879eb78075f7f7b0a7e31119a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00401_a4d9cf77879eb78075f7f7b0a7e31119a_icgraph}
\end{center}
\end{figure}
