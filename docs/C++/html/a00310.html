<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Analysis: HF::VisibilityGraph Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00305.html">HF</a></li><li class="navelem"><a class="el" href="a00310.html">VisibilityGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HF::VisibilityGraph Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Evaluate visibility between points in a set of locations.  
<a href="a00310.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af811d21e4c49275521912df9254bb737"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#af811d21e4c49275521912df9254bb737">HeightCheck</a> (const <a class="el" href="a01224.html">Node</a> &amp;<a class="el" href="a01224.html">Node</a>, float height, <a class="el" href="a01196.html">EmbreeRayTracer</a> &amp;ert)</td></tr>
<tr class="memdesc:af811d21e4c49275521912df9254bb737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if Node can be raised by height without clipping into any geometry.  <a href="a00310.html#af811d21e4c49275521912df9254bb737">More...</a><br /></td></tr>
<tr class="separator:af811d21e4c49275521912df9254bb737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cddfd8eb7ae23f8ecea0277ad5c3cc5"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#a5cddfd8eb7ae23f8ecea0277ad5c3cc5">HeightCheckAllNodes</a> (const vector&lt; <a class="el" href="a01224.html">Node</a> &gt; &amp;nodes_to_filter, float height, <a class="el" href="a01196.html">EmbreeRayTracer</a> &amp;ert)</td></tr>
<tr class="memdesc:a5cddfd8eb7ae23f8ecea0277ad5c3cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the indexes of all nodes that pass the HeightCheck.  <a href="a00310.html#a5cddfd8eb7ae23f8ecea0277ad5c3cc5">More...</a><br /></td></tr>
<tr class="separator:a5cddfd8eb7ae23f8ecea0277ad5c3cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9cf77879eb78075f7f7b0a7e31119a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#a4d9cf77879eb78075f7f7b0a7e31119a">IsOcclusionBetween</a> (const <a class="el" href="a01224.html">Node</a> &amp;node_a, const <a class="el" href="a01224.html">Node</a> &amp;node_b, <a class="el" href="a01196.html">EmbreeRayTracer</a> &amp;ert, float height=1.7f, float pre_calculated_distance=0.0f)</td></tr>
<tr class="memdesc:a4d9cf77879eb78075f7f7b0a7e31119a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a line of sight check between two nodes.  <a href="a00310.html#a4d9cf77879eb78075f7f7b0a7e31119a">More...</a><br /></td></tr>
<tr class="separator:a4d9cf77879eb78075f7f7b0a7e31119a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12eb1e4c06400c4625cd22d925927b03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01220.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#a12eb1e4c06400c4625cd22d925927b03">AllToAll</a> (<a class="el" href="a01196.html">HF::RayTracer::EmbreeRayTracer</a> &amp;ert, const std::vector&lt; <a class="el" href="a01224.html">HF::SpatialStructures::Node</a> &gt; &amp;input_nodes, float height=1.7f)</td></tr>
<tr class="memdesc:a12eb1e4c06400c4625cd22d925927b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Visibility Graph between every node in a set of nodes in parallel.  <a href="a00310.html#a12eb1e4c06400c4625cd22d925927b03">More...</a><br /></td></tr>
<tr class="separator:a12eb1e4c06400c4625cd22d925927b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42a5aafdfcc29b6a668355c07602efb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01220.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#ae42a5aafdfcc29b6a668355c07602efb">GroupToGroup</a> (<a class="el" href="a01196.html">HF::RayTracer::EmbreeRayTracer</a> &amp;ert, const std::vector&lt; <a class="el" href="a01224.html">HF::SpatialStructures::Node</a> &gt; &amp;from, const std::vector&lt; <a class="el" href="a01224.html">HF::SpatialStructures::Node</a> &gt; &amp;to, float height=1.7f)</td></tr>
<tr class="memdesc:ae42a5aafdfcc29b6a668355c07602efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Visibility Graph from a set of nodes to another set of nodes.  <a href="a00310.html#ae42a5aafdfcc29b6a668355c07602efb">More...</a><br /></td></tr>
<tr class="separator:ae42a5aafdfcc29b6a668355c07602efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1db87927118f70786a664c3b3cc7905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01220.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#ab1db87927118f70786a664c3b3cc7905">AllToAllUndirected</a> (<a class="el" href="a01196.html">HF::RayTracer::EmbreeRayTracer</a> &amp;ert, const std::vector&lt; <a class="el" href="a01224.html">HF::SpatialStructures::Node</a> &gt; &amp;nodes, float height, int cores=-1)</td></tr>
<tr class="memdesc:ab1db87927118f70786a664c3b3cc7905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a Visibility Graph with every edge stored twice.  <a href="a00310.html#ab1db87927118f70786a664c3b3cc7905">More...</a><br /></td></tr>
<tr class="separator:ab1db87927118f70786a664c3b3cc7905"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Evaluate visibility between points in a set of locations. </p>
<p>A Visibility Graph is a graph of points of space locations that have a clear line of sight to eachother.</p>
<p>Edges in Visibility Graph are bidirectional, since if one node can see another node, the inverse is true. Generating a Visibility Graph from a set of nodes consists of performing a line of sight check between each combination of nodes, and creating an edge if the line of sight check passes.</p>
<dl class="section remark"><dt>Remarks</dt><dd>One can quickly summarize the information in a Visibility Graph by summarizing the values of its edges for each node in the graph.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01220.html" title="A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.">HF::SpatialStructures::Graph</a> for more info on the Graph Datatype that is returned from all functions in the <a class="el" href="a00310.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a> namespace. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a12eb1e4c06400c4625cd22d925927b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12eb1e4c06400c4625cd22d925927b03">&#9670;&nbsp;</a></span>AllToAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01220.html">HF::SpatialStructures::Graph</a> HF::VisibilityGraph::AllToAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01196.html">HF::RayTracer::EmbreeRayTracer</a> &amp;&#160;</td>
          <td class="paramname"><em>ert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a01224.html">HF::SpatialStructures::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em> = <code>1.7f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a Visibility Graph between every node in a set of nodes in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ert</td><td>A Raytracer conatining the geometry to use as obstacles for occlusion checks. </td></tr>
    <tr><td class="paramname">input_nodes</td><td>X,Y,Z locations of nodes for the Visibility Graph. </td></tr>
    <tr><td class="paramname">height</td><td>Height to offset nodes in the z-direction before generating the <a class="el" href="a00310.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="a00310.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a> for generated from every node in input_nodes. The cost of each edge in the graph is equal to the distance between both nodes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After nodes are offset from the ground, a check is performed to determine if it intersects any geometry. If offsetting the node causes it to intersect any geometry,then the node will not be considered for connections with other nodes and will always have no outgoing or incoming edges.</dd></dl>
<p>Every node is offset height meters off the ground, then an occlusion ray is cast between every set of nodes. If this occlusion ray does not intersect any geometry then an edge is created between the set of nodes with a cost equal to the distance between both nodes. The Graph generated by this algorithm is directed, however for each pair of nodes the edge is only stored in the node with the lower ID. This reduces the size of the graph in memory by about 50% and reduces the number of checks since every node will only need to check for edges with nodes that have a higher ID than itself.</p>
<dl class="section user"><dt>Parallelism</dt><dd>Edges are checked on a seperate core for each node. This algorithm will always use every core on a user's machine.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>The time complexity of this algorithm is O(n^2), performing approximately (n^2+n)/2 operations gauranteed for each execution. The space complexity matches the time complexity, but the actual space used can be less depending on the number of edges created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00310.html#ab1db87927118f70786a664c3b3cc7905" title="Generate a Visibility Graph with every edge stored twice.">AllToAllUndirected</a> for a version of this algorithm that checks for edges between every node in nodes regardless of ID. </dd>
<dd>
<a class="el" href="a00310.html#ae42a5aafdfcc29b6a668355c07602efb" title="Generate a Visibility Graph from a set of nodes to another set of nodes.">GroupToGroup</a> For an algortithm that only calculates a visibility graph for one <a class="el" href="a00011.html#ac812385b35e52a68f2eba8435fb7b1bf">set</a> of nodes to another <a class="el" href="a00011.html#ac812385b35e52a68f2eba8435fb7b1bf">set</a> of nodes.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;objloader.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// path to OBJ file for a flat plane</span></div>
<div class="line">std::string plane_path = <span class="stringliteral">&quot;plane.obj&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a vector of MeshInfo from plane_path, using LoadMeshObjects. Note that</span></div>
<div class="line"><span class="comment">// LoadMeshObjects has two more arguments after plane_path - an enum</span></div>
<div class="line"><span class="comment">// HF::Geometry::GROUP_METHOD (defaults to GROUP_METHOD::ONLY_FILE) a bool</span></div>
<div class="line"><span class="comment">// (defaults to true, used to convert OBJ coordinate system to Rhino coordinates)</span></div>
<div class="line">std::vector&lt;HF::Geometry::MeshInfo&gt; meshInfo = <a class="code" href="a00312.html#ad32d656c7a8c84beded49e1f14f64176">HF::Geometry::LoadMeshObjects</a>(plane_path);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an EmbreeRayTracer.</span></div>
<div class="line"><a class="code" href="a01196.html">HF::RayTracer::EmbreeRayTracer</a> tracer(meshInfo);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; node_vec;      <span class="comment">// container of nodes</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> reserve_count = 100;                          <span class="comment">// pre-defined reserve size</span></div>
<div class="line">node_vec.reserve(reserve_count);                        <span class="comment">// reserve reserve_count blocks for node_vec</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Construct reserve_count Node and insert each of them into node_vec</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">float</span> i = -5.0; i &lt; 5.0; i++) {</div>
<div class="line">    <span class="comment">// runs 10 times</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">float</span> j = -5; j &lt; 5.0; j++) {</div>
<div class="line">        <span class="comment">// runs 10 times</span></div>
<div class="line">        node_vec.emplace_back(Node(i, j, 0.0f));    <span class="comment">// all Node ID default to -1</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// AllToAll constructs and returns a Graph consisting of Node (from node_vec)</span></div>
<div class="line"><span class="comment">// that do not occlude each other</span></div>
<div class="line"><span class="keywordtype">float</span> desired_height = 2.0f;        <span class="comment">// Height of graph</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph = <a class="code" href="a00310.html#a12eb1e4c06400c4625cd22d925927b03">AllToAll</a>(tracer, node_vec, desired_height);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00029_source.html#l00128">128</a> of file <a class="el" href="a00029_source.html">visibility_graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a01521_source.html#l00040">HF::SpatialStructures::Node::distanceTo()</a>, <a class="el" href="a00029_source.html#l00069">HeightCheckAllNodes()</a>, and <a class="el" href="a00029_source.html#l00103">IsOcclusionBetween()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00290_source.html#l00016">CreateVisibilityGraphAllToAll()</a>.</p>

</div>
</div>
<a id="ab1db87927118f70786a664c3b3cc7905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1db87927118f70786a664c3b3cc7905">&#9670;&nbsp;</a></span>AllToAllUndirected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01220.html">HF::SpatialStructures::Graph</a> HF::VisibilityGraph::AllToAllUndirected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01196.html">HF::RayTracer::EmbreeRayTracer</a> &amp;&#160;</td>
          <td class="paramname"><em>ert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a01224.html">HF::SpatialStructures::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cores</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a Visibility Graph with every edge stored twice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ert</td><td>A Raytracer conatining the geometry to use as obstacles for occlusion checks. </td></tr>
    <tr><td class="paramname">from</td><td>X,Y,Z locations of nodes to create the visibility graph from. </td></tr>
    <tr><td class="paramname">Height</td><td>to offset nodes in the z-direction before generating the <a class="el" href="a00310.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a>. </td></tr>
    <tr><td class="paramname">cores</td><td>number of cores to use for parallel processing. -1 will use all available cores.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="a00310.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a> generated from every node in input_nodes. The cost of each edge in the graph is equal to the distance between both nodes.</dd></dl>
<p>Similar to <a class="el" href="a00310.html#a12eb1e4c06400c4625cd22d925927b03" title="Generate a Visibility Graph between every node in a set of nodes in parallel.">VisibilityGraph::AllToAll</a>, however every edge is stored in both nodes that it connects. For example, An edge betwee node 1 and node 2 would only be stored in node 1 in AllToAll, however here the edge would exist in both node1, and node2, in this algorithm.</p>
<dl class="section remark"><dt>Remarks</dt><dd>In most cases it's preferred to use <a class="el" href="a00310.html#a12eb1e4c06400c4625cd22d925927b03" title="Generate a Visibility Graph between every node in a set of nodes in parallel.">VisibilityGraph::AllToAll</a> since it saves a lot of time and space, however it may be advantageous to have edges stored in both nodes for certain applications.</dd></dl>
<dl class="section user"><dt>Parallelism</dt><dd>Edges are checked on a seperate core for each node. This algorithm will use every core on a user's machine if cores is set to -1. Otherwise it will use the number of cores specified in cores.</dd></dl>
<dl class="section user"><dt>complexity</dt><dd>O(n^2) in space and time. <br  />
</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;objloader.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// path to OBJ file for a flat plane</span></div>
<div class="line">std::string plane_path = <span class="stringliteral">&quot;plane.obj&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a vector of MeshInfo from plane_path, using LoadMeshObjects. Note that</span></div>
<div class="line"><span class="comment">// LoadMeshObjects has two more arguments after plane_path - an enum</span></div>
<div class="line"><span class="comment">// HF::Geometry::GROUP_METHOD (defaults to GROUP_METHOD::ONLY_FILE) a bool</span></div>
<div class="line"><span class="comment">// (defaults to true, used to convert OBJ coordinate system to Rhino coordinates)</span></div>
<div class="line">std::vector&lt;HF::Geometry::MeshInfo&gt; meshInfo = <a class="code" href="a00312.html#ad32d656c7a8c84beded49e1f14f64176">HF::Geometry::LoadMeshObjects</a>(plane_path);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an EmbreeRayTracer.</span></div>
<div class="line"><a class="code" href="a01196.html">HF::RayTracer::EmbreeRayTracer</a> tracer(meshInfo);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; node_vec;      <span class="comment">// container of nodes</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> reserve_count = 100;                          <span class="comment">// pre-defined reserve size</span></div>
<div class="line">node_vec.reserve(reserve_count);                        <span class="comment">// reserve reserve_count blocks for node_vec</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Construct reserve_count Node and insert each of them into node_vec</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">float</span> i = -5.0; i &lt; 5.0; i++) {</div>
<div class="line">    <span class="comment">// runs 10 times</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">float</span> j = -5; j &lt; 5.0; j++) {</div>
<div class="line">        <span class="comment">// runs 10 times</span></div>
<div class="line">        node_vec.emplace_back(<a class="code" href="a01224.html">HF::SpatialStructures::Node</a>(i, j, 0.0f)); <span class="comment">// all Node ID default to -1</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// AllToAllUndirected constructs and returns a Graph consisting of Node (from</span></div>
<div class="line"><span class="comment">// node_vec) that do not occlude each other</span></div>
<div class="line"><span class="keywordtype">float</span> desired_height = 2.0f;        <span class="comment">// Height of graph</span></div>
<div class="line"><span class="keywordtype">int</span> core_count = 4;                 <span class="comment">// For omp_set_num_threads(int num_threads), CPU core count</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph =</div>
<div class="line">    <a class="code" href="a00310.html#ab1db87927118f70786a664c3b3cc7905">HF::VisibilityGraph::AllToAllUndirected</a>(tracer, node_vec, desired_height, core_count);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00029_source.html#l00252">252</a> of file <a class="el" href="a00029_source.html">visibility_graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a01521_source.html#l00040">HF::SpatialStructures::Node::distanceTo()</a>, <a class="el" href="a00029_source.html#l00069">HeightCheckAllNodes()</a>, and <a class="el" href="a00029_source.html#l00103">IsOcclusionBetween()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00290_source.html#l00040">CreateVisibilityGraphAllToAllUndirected()</a>.</p>

</div>
</div>
<a id="ae42a5aafdfcc29b6a668355c07602efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42a5aafdfcc29b6a668355c07602efb">&#9670;&nbsp;</a></span>GroupToGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01220.html">HF::SpatialStructures::Graph</a> HF::VisibilityGraph::GroupToGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01196.html">HF::RayTracer::EmbreeRayTracer</a> &amp;&#160;</td>
          <td class="paramname"><em>ert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a01224.html">HF::SpatialStructures::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a01224.html">HF::SpatialStructures::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em> = <code>1.7f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a Visibility Graph from a set of nodes to another set of nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ert</td><td>A Raytracer conatining the geometry to use as obstacles for occlusion checks. </td></tr>
    <tr><td class="paramname">from</td><td>X,Y,Z locations of nodes to cast rays from. </td></tr>
    <tr><td class="paramname">to</td><td>X,Y,Z locations of nodes to cast rays to. </td></tr>
    <tr><td class="paramname">Height</td><td>to offset nodes in the z-direction before generating the <a class="el" href="a00310.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="a00310.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a> generated from every node in from to every node in to. The cost of each edge in the graph is equal to the distance between both nodes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The ID of nodes in the new graph wil correspond to the node's location in the from or to arrays. First every node in from will in from be placed in order, then every node in to will be placed in order. This means that the ID of every node in from will be equal to its index in from, and the ID of every node in to will be equal to the number of nodes in from plus its index in to.</dd></dl>
<p>The algorithm used here is similar to that of <a class="el" href="a00310.html#a12eb1e4c06400c4625cd22d925927b03" title="Generate a Visibility Graph between every node in a set of nodes in parallel.">VisibilityGraph::AllToAll</a>, however edges are cast from every node in from to every node in to. All nodes in to will have no outgoing edges.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This can be useful for generating the visibility graph for a subset of nodes, such as the visibility from a building to the outside, without needing to calculate the visibility from every node to every other node.</dd></dl>
<dl class="section user"><dt>Parallelism</dt><dd>Edges are checked on a seperate core for each node. This algorithm will always use every core on a user's machine.</dd></dl>
<dl class="section user"><dt>Complexity</dt><dd>In time: O(ft) where f is the number of nodes in from, and t is the number of nodes in to. In space, O(ft) as well.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// be sure to #include &quot;objloader.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// path to OBJ file for a flat plane</span></div>
<div class="line">std::string plane_path = <span class="stringliteral">&quot;plane.obj&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a vector of MeshInfo from plane_path, using LoadMeshObjects. Note that</span></div>
<div class="line"><span class="comment">// LoadMeshObjects has two more arguments after plane_path - an enum</span></div>
<div class="line"><span class="comment">// HF::Geometry::GROUP_METHOD (defaults to GROUP_METHOD::ONLY_FILE) a bool</span></div>
<div class="line"><span class="comment">// (defaults to true, used to convert OBJ coordinate system to Rhino coordinates)</span></div>
<div class="line">std::vector&lt;HF::Geometry::MeshInfo&gt; meshInfo = <a class="code" href="a00312.html#ad32d656c7a8c84beded49e1f14f64176">HF::Geometry::LoadMeshObjects</a>(plane_path);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create an EmbreeRayTracer.</span></div>
<div class="line"><a class="code" href="a01196.html">HF::RayTracer::EmbreeRayTracer</a> tracer(meshInfo);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; node_vec_0;        <span class="comment">// First container of Node</span></div>
<div class="line">std::vector&lt;HF::SpatialStructures::Node&gt; node_vec_1;        <span class="comment">// Second container of Node</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> reserve_count = 100;      <span class="comment">// Pre-defined reserve size</span></div>
<div class="line">node_vec_0.reserve(reserve_count);  <span class="comment">// Reserve reserve_count blocks for both vectors</span></div>
<div class="line">node_vec_1.reserve(reserve_count);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 0) Construct reserve_count Node and insert each of them into node_vec_0</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">float</span> i = -5.0; i &lt; 5.0; i++) {</div>
<div class="line">    <span class="comment">// runs 10 times</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">float</span> j = -5.0; j &lt; 5.0; j++) {</div>
<div class="line">        <span class="comment">// runs 10 times</span></div>
<div class="line">        node_vec_0.emplace_back(<a class="code" href="a01224.html">HF::SpatialStructures::Node</a>(i, j, 0.0f));   <span class="comment">// all Node ID default to -1</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1) Construct reserve_count Node and insert each of them into node_vec_1</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">float</span> i = 0.0; i &lt; 10.0; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">float</span> j = 0.0; j &lt; 10.0; j++) {</div>
<div class="line">        node_vec_1.emplace_back(<a class="code" href="a01224.html">HF::SpatialStructures::Node</a>(i, j, 0.0f));   <span class="comment">// all Node ID default to -1</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// GroupToGroup constructs and returns a Graph consisting of Node (between</span></div>
<div class="line"><span class="comment">// node_vec_0 and node_vec_1) such that the nodes do not occlude each other</span></div>
<div class="line"><span class="keywordtype">float</span> desired_height = 2.0f;        <span class="comment">// Height of graph</span></div>
<div class="line"><a class="code" href="a01220.html">HF::SpatialStructures::Graph</a> graph = <a class="code" href="a00310.html#ae42a5aafdfcc29b6a668355c07602efb">HF::VisibilityGraph::GroupToGroup</a>(tracer, node_vec_0, node_vec_1, desired_height);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="a00029_source.html#l00189">189</a> of file <a class="el" href="a00029_source.html">visibility_graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a01521_source.html#l00040">HF::SpatialStructures::Node::distanceTo()</a>, <a class="el" href="a00029_source.html#l00069">HeightCheckAllNodes()</a>, and <a class="el" href="a00029_source.html#l00103">IsOcclusionBetween()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00290_source.html#l00064">CreateVisibilityGraphGroupToGroup()</a>.</p>

</div>
</div>
<a id="af811d21e4c49275521912df9254bb737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af811d21e4c49275521912df9254bb737">&#9670;&nbsp;</a></span>HeightCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::VisibilityGraph::HeightCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01196.html">EmbreeRayTracer</a> &amp;&#160;</td>
          <td class="paramname"><em>ert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if Node can be raised by height without clipping into any geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Node</td><td>Node to perform height check on. </td></tr>
    <tr><td class="paramname">height</td><td>Distance to check above the node in meters. Default = 1.7m. </td></tr>
    <tr><td class="paramname">ert</td><td>Raytracer containing geometry to intersect with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if Node can be raised by height without intersecting with any geometry. False otherwise.</dd></dl>
<p>Cast an occlusion ray straight up with a distance of height to determine if it will intersect with any geometry.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This is useful to prevent nodes from going through ceilings or other geometry when comparing the scores of all nodes in a model. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00029_source.html#l00047">47</a> of file <a class="el" href="a00029_source.html">visibility_graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00137_source.html#l00994">HF::RayTracer::EmbreeRayTracer::FireAnyOcclusionRay()</a>, and <a class="el" href="a00155_source.html#l00029">HF::SpatialStructures::ROUNDING_PRECISION</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00029_source.html#l00069">HeightCheckAllNodes()</a>.</p>

</div>
</div>
<a id="a5cddfd8eb7ae23f8ecea0277ad5c3cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cddfd8eb7ae23f8ecea0277ad5c3cc5">&#9670;&nbsp;</a></span>HeightCheckAllNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; HF::VisibilityGraph::HeightCheckAllNodes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="a01224.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes_to_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01196.html">EmbreeRayTracer</a> &amp;&#160;</td>
          <td class="paramname"><em>ert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the indexes of all nodes that pass the HeightCheck. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes_to_filter</td><td>Nodes to perform the height check on </td></tr>
    <tr><td class="paramname">height</td><td>Height to check above the nodes </td></tr>
    <tr><td class="paramname">ert</td><td>Raytracer containing the geometry to use as obstacles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The indexes in nodes_to_filter of all nodes that pass the height check.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00310.html#af811d21e4c49275521912df9254bb737" title="Check if Node can be raised by height without clipping into any geometry.">HeightCheck</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00029_source.html#l00069">69</a> of file <a class="el" href="a00029_source.html">visibility_graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00029_source.html#l00047">HeightCheck()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00029_source.html#l00128">AllToAll()</a>, <a class="el" href="a00029_source.html#l00252">AllToAllUndirected()</a>, and <a class="el" href="a00029_source.html#l00189">GroupToGroup()</a>.</p>

</div>
</div>
<a id="a4d9cf77879eb78075f7f7b0a7e31119a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9cf77879eb78075f7f7b0a7e31119a">&#9670;&nbsp;</a></span>IsOcclusionBetween()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HF::VisibilityGraph::IsOcclusionBetween </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01224.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01196.html">EmbreeRayTracer</a> &amp;&#160;</td>
          <td class="paramname"><em>ert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em> = <code>1.7f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pre_calculated_distance</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a line of sight check between two nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_a</td><td>Node to check occlusion from. </td></tr>
    <tr><td class="paramname">node_b</td><td>Node to check occlusion to. </td></tr>
    <tr><td class="paramname">ert</td><td>Raytracer containing the geometry to use as obstacles. </td></tr>
    <tr><td class="paramname">height</td><td>Distance to offset a node in the z-direction before performing the check. </td></tr>
    <tr><td class="paramname">pre_calculated_distance</td><td>Distance from node_a to node_b. If set to zero then this will be calculated automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is an obstacle blocking line of sight between node_a and node_b when raised to height.</dd></dl>
<p>Calculate the distance between node_a and node_b if required, then calculate the direction between them. Cast an occlusion ray in the direction between node_a and node_b with a maximum distance equal to the distance between them. If the ray intersects anything then the nodes don't have a line of sight. </p>

<p class="definition">Definition at line <a class="el" href="a00029_source.html#l00103">103</a> of file <a class="el" href="a00029_source.html">visibility_graph.cpp</a>.</p>

<p class="reference">References <a class="el" href="a01521_source.html#l00131">HF::SpatialStructures::Node::directionTo()</a>, <a class="el" href="a01521_source.html#l00040">HF::SpatialStructures::Node::distanceTo()</a>, and <a class="el" href="a00137_source.html#l00994">HF::RayTracer::EmbreeRayTracer::FireAnyOcclusionRay()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00029_source.html#l00128">AllToAll()</a>, <a class="el" href="a00029_source.html#l00252">AllToAllUndirected()</a>, and <a class="el" href="a00029_source.html#l00189">GroupToGroup()</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aa01224_html"><div class="ttname"><a href="a01224.html">HF::SpatialStructures::Node</a></div><div class="ttdoc">A point in space with an ID.</div><div class="ttdef"><b>Definition:</b> <a href="a00176_source.html#l00038">node.h:38</a></div></div>
<div class="ttc" id="aa00312_html_ad32d656c7a8c84beded49e1f14f64176"><div class="ttname"><a href="a00312.html#ad32d656c7a8c84beded49e1f14f64176">HF::Geometry::LoadMeshObjects</a></div><div class="ttdeci">vector&lt; MeshInfo &gt; LoadMeshObjects(std::string path, GROUP_METHOD gm, bool change_coords)</div><div class="ttdoc">Create MeshInfo instances from the OBJ at path.</div><div class="ttdef"><b>Definition:</b> <a href="a00113_source.html#l00033">objloader.cpp:33</a></div></div>
<div class="ttc" id="aa01196_html"><div class="ttname"><a href="a01196.html">HF::RayTracer::EmbreeRayTracer</a></div><div class="ttdoc">A wrapper for Intel's Embree Library.</div><div class="ttdef"><b>Definition:</b> <a href="a00137_source.html#l00061">embree_raytracer.h:61</a></div></div>
<div class="ttc" id="aa00310_html_ae42a5aafdfcc29b6a668355c07602efb"><div class="ttname"><a href="a00310.html#ae42a5aafdfcc29b6a668355c07602efb">HF::VisibilityGraph::GroupToGroup</a></div><div class="ttdeci">Graph GroupToGroup(EmbreeRayTracer &amp;ert, const vector&lt; Node &gt; &amp;from, const vector&lt; Node &gt; &amp;to, float height)</div><div class="ttdoc">Generate a Visibility Graph from a set of nodes to another set of nodes.</div><div class="ttdef"><b>Definition:</b> <a href="a00029_source.html#l00189">visibility_graph.cpp:189</a></div></div>
<div class="ttc" id="aa00310_html_ab1db87927118f70786a664c3b3cc7905"><div class="ttname"><a href="a00310.html#ab1db87927118f70786a664c3b3cc7905">HF::VisibilityGraph::AllToAllUndirected</a></div><div class="ttdeci">Graph AllToAllUndirected(EmbreeRayTracer &amp;ert, const vector&lt; Node &gt; &amp;nodes, float height, int cores)</div><div class="ttdoc">Generate a Visibility Graph with every edge stored twice.</div><div class="ttdef"><b>Definition:</b> <a href="a00029_source.html#l00252">visibility_graph.cpp:252</a></div></div>
<div class="ttc" id="aa00310_html_a12eb1e4c06400c4625cd22d925927b03"><div class="ttname"><a href="a00310.html#a12eb1e4c06400c4625cd22d925927b03">HF::VisibilityGraph::AllToAll</a></div><div class="ttdeci">Graph AllToAll(EmbreeRayTracer &amp;ert, const vector&lt; Node &gt; &amp;nodes, float height)</div><div class="ttdoc">Generate a Visibility Graph between every node in a set of nodes in parallel.</div><div class="ttdef"><b>Definition:</b> <a href="a00029_source.html#l00128">visibility_graph.cpp:128</a></div></div>
<div class="ttc" id="aa01220_html"><div class="ttname"><a href="a01220.html">HF::SpatialStructures::Graph</a></div><div class="ttdoc">A Graph of nodes connected by edges that supports both integers and HF::SpatialStructures::Node.</div><div class="ttdef"><b>Definition:</b> <a href="a00173_source.html#l00268">graph.h:268</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
